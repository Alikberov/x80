<html>
<head>
<meta http-equiv='refresh' content='50000' />
<title>x80 - Rebused Instruction Set Computer</title>
<!--
Представляемая концепция процессорного устройства базируется на переработанной
системе команд процессора i8080 с полной утратой совместимости уровня машинных
команд и с частично достигнутой совместимостью с ассемблером процессора i8086.
------------------------------------------------------------------------------
Таблица системы команд процессора была расчитана под интуитивное восприятие на
принципе ассоциативных предпосылок субъективного уровня с учитыванием реальной
возможной частоты использования различных инструкций в построениях алгоритмов.
Некоторые из инструкций, в силу морального устаревания и потерей актуальности,
были изначально исключены или получили более комплексный код редкой комбинации
обычных команд, чтобы не засорять таблицу и сохранять перспективу наращивания.
Регистр статуса процессора был переорганизован и флажки АЛУ получили частичную
связь на дешифратор команд с возможностью управлять периодом выполнения команд
для явного объявления условно реактивных и ленивых участков программного кода.
------------------------------------------------------------------------------
Флаги: Регистр состояния процессора/АЛУ
=======================================
Регистр состояния FX является старшим AH в AX, разделён на два ниббла FH и FL.
Старшим нибблом хранится индекс опционального регистра/указателя или итерации.
Младшим нибблом отражается комбинация режима дешифратора инструкций с флажками
результата действий команд АЛУ. Правилами постулатов исполнения вычислительных
операций исключаются вариации нуля нечётного паритета или отрицательного нуля.
Ноль нечётного паритета запрещает регистрирование результата выполнения потока
дешифрируемых инструкций на период с декрементацией опционального регистра или
итерации в старшем ниббле, позволяя опционально пропускать цепочку инструкций.
Отрицательный ноль приостанавливает считывание следующих инструкций, организуя
цикл на период с полной или условной декрементацией опционального регистра или
итерации в старшем ниббле, позволяя опционально ставить цикл и режим ожидания.
Через режим условного ожидания организуется возможность доступа к интерфейсным
устройствам ввода/вывода или внешней шине состояния сигналов событий ресурсов,
чтобы описывать алгоритмы своевременной обработки всех допускаемых прерываний.
------------------------------------------------------------------------------
Обработка программных и аппаратных прерываний
=============================================
Архитектурой процессора не предусматривается возможность оперативной реакции в
режиме реального времени на любые внешние сигналы от периферии с генерацией по
их запросам определённых прерываний на обращение к соответствующим процедурам.
После включения ядра процессора и аппаратного сброса, управление передаётся на
нулевой контекст программы по вектору 0xFF00 с возможностью прямого доступа ко
всем ресурсам среды системы, всем контекстным файлам и к регистрам управления.
В обязанности кода основного процесса входит необходимость настройки периферии
и соответствующего реагирования на любые внешние сигналы с её стороны, а также
организации поддержки интерфейса с другим прикладным программным обеспечением.
Процесс ядра системы не имеет возможность непосредственного опроса внешних шин
и считывания их состояния без организации исполнения кода прикладного уровня с
поддержанием его нормального исполнения и надлежащего предоставления ресурсов.

В процессоре имеется восемь регистров управления контекстами задач прикладного
уровня, доступных основному процессу под комплексной манипуляцией инструкциями
управления условным ожиданием в цикле из останова .
------------------------------------------------------------------------------
Доступ к внешним устройствам и регистрам контекстного файла
===========================================================
Системой команд не предусматриваются непосредственные команды доступа к портам
ввода/вывода для взаимодействия с устройствами периферии или доступа к ячейкам
контекстного файла и управляющим регистрам представления контекстной проекции.
Подобные операции находятся за пределами области задач прикладного уровня и не
засоряют таблицу команд как специализированные инструкции, используемые крайне
редко в зонах временной необходимости сервисных процедур операционной системы.
Процессором имеется достаточное количество префиксов для организации трюкового
достижения необходимых системных ресурсов в рамках кода операционной системы и
ограниченного контролируемого прикладного трюкового доступа к нужным ресурсам.
В момент попытки доступа приложения к порту ввода/вывода, исполнение программы
временно приостанавливается и управление передаётся ядру системы с выдачей

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Примерная трюковая цепочка ;;; Макрос псевдонима мнемоники с описанием ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;	MOV	DL,[0]		;;; Чтение индекса проекции контекста
	HLT	DL		; Указываем принимающий регистр
	WAIT			; Приступаем к ожиданию системной операции
	HLT			; Считываем индекс проекции контекста
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;	MOV	[0],DL		;;; Запись индекса проекции контекста
	HLT			; Инструкция работает лишь в проекции системы
	WAIT			; Приступаем к ожиданию системной операции
	HLT	DL		; Префиксируем регистр индекса проекции
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;	MOV	DL,[DL]		;;; Читаем байт файла контекста
	HLT	DL		; Указываем принимающий регистр
	WAIT			; Готовимся читать данные
	HLT	DL		; В регистр DL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;	MOV	[DL],AL		;;; Пишем байт в файл контекста
	HLT	DL		; Указываем регистр выбора ячейки
	WAIT			; Готовимся писать данные
	HLT	AL		; в ячейку DL из регистра AL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;	MOV	DL,[1]		;;; Читаем байт регистра контроля
	HLT	DL		; Указываем принимающий регистр
	WAIT			; Готовимся читать данные
	HLT	1		; В регистр DL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;	MOV	[1],DL		;;; Пишем байт в регистр контроля
	HLT	1		; Указываем регистр контроля
	WAIT			; Готовимся писать данные
	HLT	DL		; в ячейку из регистра DL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;	IN	DH		;;; Читаем данные с порта
	HLT	1		; Вибираем индекс регистра BH
	WAIT			; Готовимся читать данные
	HLT	1		; В регистр BH
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;	OUT	[DH],CH		;;; Пишем данные в порт
	HLT	1		; Выбираем индексирующий регистра
	WAIT			; Готовимся писать данные
	HLT	2		; в порт BH из регистра CH
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IRQ:	;;;;;;;;;;;;;;;;;;;;;;;;; Тело обработчика прерываний
	JMP	.overhead	; Запрос к стандартному API
	JMP	.acclaim	; Обращение к программным прерываниям INT 0-79
	JMP	.buffer		; Буферная зона - прослойка диспетчера памяти
	JMP	.context	; Диспетчер переключения контекстов процессов
	JMP	.device		; Запрос ко внешнему устройству ввода/вывода
	JMP	.error		; Обработчик программных/аппаратных ошибок
	JMP	.force		; Внешние форсированные события/прерывания
	JMP	.garret		; Загрузочная область поверхностного уровня
.context:	;;;;;;;;;;;;;;;;; Тело диспетчера контекста
	XOR	AL,AL		; Подготавливаем регистр к чтению регистра CR
	HLT	AL		; Определяем его как приёмник
	WAIT			; Переход в условный цикл
	HLT	7		; Считываем содержимое CR[7] в AL
	;;;	;;;	;;;	; Оперативные действия с контекстом
	MOV	AL,0x01		; Выставляем индекс выбираемого контекста
	CMP	AL,AL		; Сброс флага переноса CF
	CMC			; Устанавливаем флаг, если требуется протокол
	HLT	AL		; Определяем его как источник
	WAIT			; Переход в условный цикл
	HLT			; Финальная запись байта регистра AL в CR[0]
.device:	;;;;;;;;;;;;;;;;; Тело диспетчера периферии

00000000|Kernel Mode Execution
0xxxxxxx|Kernel Mode Access
10000000|
1xxxxxxx|User Mode Execution
-->
<!--
span.CPU_Group__ {
	background-color: #012;
	cursor		: pointer;
}
span.CPU_Group_A {
	background-color: #771;
}
span.CPU_Group_B {
	background-color: #751;
}
span.CPU_Group_C {
	background-color: #411;
}
span.CPU_Group_D {
	background-color: #551;
}
span.CPU_Group_E {
	background-color: #161;
}
span.CPU_Group_F {
	background-color: #157;
}
-->
<!--
span.CPU_Group__ {
	background-color: #012;
	cursor		: pointer;
}
span.CPU_Group_A {
	background-color: blue;
}
span.CPU_Group_B {
	background-color: brown;
}
span.CPU_Group_C {
	background-color: cyan;
}
span.CPU_Group_D {
	background-color: red;
}
span.CPU_Group_E {
	background-color: #161;
}
span.CPU_Group_F {
	background-color: magenta;
}
-->
<!--
A:ALU
B:Branch
C:Control
D:Dubbed register pair
E:Stack
F:Flip-flop move
-->
<style>
span[class^=CPU_Group_] {
	border		: none;
	color		: brightgreen;
	cursor		: default;
	margin		: 0px 0px 0px 0px;
	padding		: none;
}
span.active {
	text-decoration	: overline underline;
}
span.halted {
	color		: magenta;
	cursor		: cell;
}
span.CPU_Group__ {
	background-color: #012;
	cursor		: pointer;
}
span.CPU_Group_A {
	background-color: #772;	<!--	ALU		- AND/XOR/CMP	772-->
}
span.CPU_Group_B {
	background-color: #764;	<!--	Branching	- Ccnd/Jcnd	752-->
}
span.CPU_Group_C {
	background-color: #888;	<!--	Controls	- HLT/NOP	888-->
}
span.CPU_Group_D {
	background-color: #663;	<!--	Dubbed/Pair	- INC/DEC	552-->
}
span.CPU_Group_E {
	background-color: #363;	<!--	Xchg/Stack	- POP/PUSH	262-->
}
span.CPU_Group_F {
	background-color: #367;	<!--	Flip-Flop	- MOV		257-->
}
span.CPU_Group_X {
	background-color: #437;	<!--	X-Code		- ---		437-->
}
span.CPU_Group_Z {
	background-color: #444;	<!--	X-Code		- ---		437-->
}

body {
	background-color: black;
	color		: lightgreen;
	padding		: 0 0 0 0;
	margin		: 0 0 0 0;
	overflow	: auto;
}
input {
	border		: none;
	border-spacing	: 0px 0px;
	background-color: grey;
	font-family	: Courier New;
	font-size	: 9px;
	margin		: 0 0 0 0;
	padding		: 0 0 0 0;
}
table {
	border		: none;
	border-spacing	: 0px 0px;
	font-family	: Courier New;
	font-size	: 9px;
}
tr {
	margin			: 10px 10px 10px 10px;
	padding			: none;
}
td {
	border-top	: none;
	border-left	: none;
	border-right	: thin green solid;
	border-bottom	: thin green solid;
}

button {
	padding		: 0 0 0 0;
	margin		: 0 0 0 0;
	font-size	: 7px; width: 4em;
}
pre#state {
	padding		: 0 0 0 0;
	margin		: 0 0 0 0;
}
pre {
	margin		: 0px 0px 0px 0px;
}
textarea {
	border		: none;
	padding		: 0 0 0 0;
	margin		: 0px 0px 0px 0px;
	font-family	: Courier;
	font-height	: 19px;
	font-size	: 8px;
}
textarea#Files {
	display		: none;
}
pre#Screen {
	margin		: 0px 0px 0px 0px;
	font-family	: Courier;
	font-size	: 10px;
	font-width	: 14px;
	//border		: thick grey inset;
}
pre#commands {
	cursor		: default;
}
var {
	display		: none;
}
span.prefix {
	cursor		: pointer;
}
span.prefix:hover {
	color		: yellow;
	font-weight	: bolder;
}
</style>
<script>
/****************************************************************************/
Number.prototype.Hex = function(n) {
	return	(n < 0 ? "0x" : "") + ((((this >> 16) & 0x0000FFFF) | 0x00010000).toString(16) + ((this & 0x0000FFFF) | 0x00010000).toString(16).substr(1)).substr(-Math.abs(n)).toUpperCase();
}
Number.prototype.hi = function(n) {
	if(isFinite(n))
		return (this & 0x00FF) | ((n & 0x00FF) << 8);
	return (this >> 8) & 0x00FF;
}
Number.prototype.lo = function(n) {
	if(isFinite(n))
		return (this & 0xFF00) | (n & 0x00FF);
	return this & 0x00FF;
}
Number.prototype.hl = function(hi, lo) {
	return	(lo & 0x00FF) | ((hi & 0x00FF) << 8);
}
String.prototype.Mul = function(n, j) {var s = this, buf = ""; while(n > 0) { if(n&1) buf+=s; s+=(j?j:"")+s; n >>= 1; } return buf; }

/* .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F
00:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|
10:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|
20:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|
30:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|
40:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|
50:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|
60:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|
70:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|
80:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|
90:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|
A0:AL>>LO>>Стек истории --|AH>>HI>> ++ .. -- -- --|AX-File 0 1
B0:BL>>LO>>модификации- --|BH>>HI>> ++ .. -- -- --|BX-File 2 3
C0:CL>>LO>>всех РОН- -- --|CH>>HI>> ++ .. -- -- --|CX-File 4 5
D0:DL>>LO>> ++ .. -- -- --|DH>>HI>> ++ .. -- -- --|DX-File 6 7
E0:SP>LO/BP>LO/SI>LO/DI>LO|SP>HI/BP>HI/SI>HI/DI>HI|SP/BP/SI/DI
F0:IP>>LO>> ++/../TL/JP.LO|IP>>HI>> ++/../TH/JP.HI|IP/JP                */
Array.prototype.Dump = function(a, n) {
	var	s = [], t = "__", d = "INT 0|INT 1|INT 2|INT 3|INT 4|INT 5|INT 6|INT 7|INT 8|INT 9|AX-File(AL:AH)|BX-File(BL:BH)|CX-File(CL:CH)|DX-File(DL:DH)|SP/BP/SI/DI|IP/JP|Services Masking".split("|");
	if(isFinite(a))
		while(n --)
			s.push(this[a ++ & 0xFFFF].Hex(2));
	else {
		n = this.length;
		for(a = 0; a < 16; ++ a)
			t += " ." + a.Hex(1);
		for(a = 0; a < n; ++ a) {
			s.push(this[a].Hex(2));
			if((a & 15) == 15)
				if(a >= 0xE0 && a <= 0xEF)
					t += "\r\n" + (a & 0xF0).Hex(2) + ":" + s.slice(0, 2).join(" ") + "/" + s.slice(2, 4).join(" ") + "/" + s.slice(4, 6).join(" ") + "/" + s.slice(6, 8).join(" "),
					t += "|" + s.slice(8, 10).join(" ") + "/" + s.slice(10, 12).join(" ") + "/" + s.slice(12, 14).join(" ") + "/" + s.slice(14, 16).join(" ") + ";" + d.shift(),
					s = [];
				else
					t += "\r\n" + (a & 0xF0).Hex(2) + ":" + s.slice(0, 8).join(" ") + "|" + s.slice(8, 16).join(" ") + ";" + d.shift(),
					s = [];
			else
			if(a == n - 1)
				t += "\r\n+0:" + s.join(" ") + ";" + d.shift();
		}
		return t;
	}
	return s.join(" ");
}
Array.prototype.Text = function(a, n) {var s = "", c; while(n --) c = this[a ++ & 0xFFFF], s += "&#" + /*String.fromCharCode*/(c >= 32 && c <= 127 ? c : 0xB7) + ";"; return s; }
Array.prototype.Chr = function(a, n, m, xy) {
	var	i, buf = "";
	var	smb = [	0xB7, 0x255D, 0x255A, 0x2569, 0x2554, 0x256A, 0x2560, 0x2510, 0xB7, 0x263A, 0xB7, 0x25B2, 0xB7, 0xB7, 0x25BA, 0x25BC,	//0xB7, 0x2598, 0x259D, 0x2580, 0x2597, 0x259A, 0x2590, 0x259C, 0xB7, 0x263A, 0xB7, 0x25B2, 0xB7, 0xB7, 0x25BA, 0x25BC,
			0x2557, 0x2563, 0x256B, 0x250C, 0x2566, 0x2514, 0x2518, 0x256C, 0xB7, 0xB7, 0xB7, 0x2551, 0x2550, 0x25C4, 0xB7, 0xB7,	//0x2596, 0x258C, 0x259E, 0x259B, 0x2584, 0x2599, 0x259F, 0x2588, 0xB7, 0xB7, 0xB7, 0x2551, 0x2550, 0x25C4, 0xB7, 0xB7,
			0x20, 0x21, 0x22, 0x23, 0xA4, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B ,0x4C, 0x4D, 0x4E, 0x4F,
			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
			0x042E, 0x0410, 0x0411, 0x0426, 0x0414, 0x0415, 0x0424, 0x0413, 0x0425, 0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E,
			0x041F, 0x042F, 0x0420, 0x0421, 0x0422, 0x0423, 0x0416, 0x0412, 0x042C, 0x042B, 0x0417, 0x0428, 0x042D, 0x0429, 0x0427, 0x25A0];
	if(isFinite(m))
		m *= n;
	else
		m = n;
	xy = isFinite(xy) ? xy : -1;
	for(i = 0; i < m; ++ i, ++ a, -- xy)
		buf += (xy ? "&#" : "<u>&#") + (this[a] >= 0 && this[a] < 128 ? smb[this[a]] : smb[0]) + (xy ? ";" : ";</u>") + (i % n == n - 1 && m != n ? "<br />" : "");
	return buf;
}
/****************************************************************************/
var
	AudioAPI = 0,
	AudioScript = 0,
	AudioStream = [],
	AudioAPIscript = 0,
	amp = [],
	osc = [];
var	noteFreq = [	//	freq = 2 ** (n / 12) * 440
		16.352, 17.324, 18.354, 19.445, 20.602, 21.827, 23.125, 24.500, 25.957, 27.500, 29.135, 30.868,
		32.703, 34.648, 36.708, 38.891, 41.203, 43.654, 46.249, 48.999, 51.913, 55.000, 58.270, 61.735,
		65.406, 69.296, 73.416, 77.782, 82.406, 87.307, 92.499, 97.999, 103.83, 110.00, 116.54, 123.47,
		130.81, 138.59, 146.83, 155.56, 164.81, 174.81, 185.00, 196.00, 207.65, 220.00, 233.08, 246.84,
		261.63, 277.18, 293.67, 311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88,	//	#1
		523.25, 554.37, 587.33, 622.25, 659.26, 698.46, 739.99, 783.99, 830.61, 880.00, 932.33, 987.77,	//	#2
		1046.5, 1108.7, 1174.7, 1244.5, 1318.5, 1396.9, 1480.0, 1568.0, 1661.2, 1760.0, 1864.7, 1975.5,	//	#3
		2093.0, 2217.5, 2349.3, 2489.0, 2637.0, 2793.8, 2960.0, 3136.0, 3322.4, 3520.0, 3729.3, 3951.1,	//	#4
		4186.0, 4434.9, 4698.6, 4978.0, 5274.0, 5587.7, 5919.9, 6271.9, 6644.9, 7040.0, 7458.6, 7902.1,	//	#5
		8372.0, 8869.8, 9397.3, 9956.1, 10548 , 11175 , 11840 , 12544 , 13290 , 14080 , 14917 , 15804	//	#6
	];
function AudioCallBack(e) {
	try {
		var	i, addr = 0xA0;
		var input = e.inputBuffer.getChannelData(0);
		var output = e.outputBuffer.getChannelData(0);
		var	frq = typeof cpu.iox[addr] == "object" ? cpu.iox[addr].data() : cpu.iox[addr];
		var	evl = 0;
		var	dur = 0;
		document.title = (frq = 440);
		dur = AudioStream.length > 0 ? AudioStream[0] : 0;
		try {
			for(i = 0; i < input.length; ++ i) {
				output[i] = dur > 0 ? 255 : 0;
				if(dur > 0)
					dur --;
				if(dur < 0)
					dur ++;
				if(dur == 0 && AudioStream.length > 0) {
					dur = AudioStream.shift();
				}
			}
			if(dur != 0)
				AudioStream[0] = dur;
		} catch(e) {
			while(i < input.length)
				output[i ++] = (Math.random() % 255 - 128) / 128;
		}
	} catch (e) {
		//window.status = e.message;
	}
}
//
function AudioInit() {
	try {
		AudioAPI = new AudioContext();
	} catch(err) {
		AudioAPI = 0;
		return;
	}
	//AudioAPIanalyser = AudioAPI.createAnalyser();
	//AudioAPIanalyser.connect(AudioAPI.destination);
	AudioAPIfilter = AudioAPI.createBiquadFilter(); 
	AudioAPIfilter.type = 1; // High-pass filter (Тип фильтра)
	AudioAPIfilter.frequency.value = 96000; // Cutoff to 1kHZ (Базовая частота)
	AudioAPIfilter.frequency.Q = 1.1; // Quality factor (Добротность)
	AudioAPIfilter.connect(AudioAPI.destination);//(AudioAPIanalyser);
	(amp[0] = AudioAPI.createGain()).connect(AudioAPIfilter); /*amp[0].connect(anl)*/; amp[0].gain.value = 1.0;
	(osc[0] = AudioAPI.createOscillator()).connect(amp[0]); osc[0].frequency.value = 440;
	try {
		osc[0].noteOn(0);
	} catch(err) {
		osc[0].start(0);
//		osc[0].stop(3);
//		osc[0].start(7);
	}
/*	if(!AudioAPI.createScriptProcessor)
		AudioAPIscript = AudioAPI.createJavaScriptNode(1 << 10, 1, 1);
	else
		AudioAPIscript = AudioAPI.createScriptProcessor(1 << 10, 1, 1);
	AudioAPIscript.onaudioprocess = AudioCallBack;
	// connect the ScriptProcessorNode with the input audio
	amp[0].connect(AudioAPIscript);
	// if the ScriptProcessorNode is not connected to an output the "onaudioprocess" event is not triggered in chrome
	AudioAPIscript.connect(amp[0]);*/
};

var
	VK = {
		BACK_SPACE	:0x08,
		TAB		:0x09,
		RETURN		:0x0D,
		BREAK		:0x13,
		CAPITAL		:0x14,
		ESC		:0x1B,
		PREV		:0x21,
		NEXT		:0x22,
		END		:0x23,
		HOME		:0x24,
		LEFT		:0x25,
		UP		:0x26,
		RIGHT		:0x27,
		DOWN		:0X28,
		PRINT		:0x2C,
		INSERT		:0x2D,
		DELETE		:0x2E,
		CONTEXT		:0x5D,
		F1		:0x70,
		F2		:0x71,
		F3		:0x72,
		F4		:0x73,
		F5		:0x74,
		F6		:0x75,
		F7		:0x76,	// Assembly
		F8		:0x77,
		F9		:0x78,	// Break point on/off
		F10		:0x79,
		F11		:0x7A,
		F12		:0x7B,
		BROWSE_BACK	:0xA6,
		BROWSE_FORWARD	:0xA7,
		BROWSE_REFRESH	:0xA8,
		BROWSE_STOP	:0xA9,
		BROWSE_SEARCH	:0xAA,
		BROWSE_HOME	:0xAC,
		PLAYER_FORWARD	:0xB0,	// Emulation IP ++
		PLAYER_REWIND	:0xB1,	// Emulation IP --
		PLAYER_STOP	:0xB2,	// Emulation stop/step
		PLAYER_PLAY	:0xB3,	// Emulation stop/start
		BROWSE_MAIL	:0xB4,
	};

var	X80 =
function(description) {
	var	_CPU_ID_	= "x80-CPU";
	var	preset = {	// Initial tables
		instructions	:[],	// Instructions set: code -> group, mnemonic, operands, expression
		mnemonics	:[],	// Mnemonical codes: name -> operands -> code
		alias		:[],	// Mnemonical alias: name -> byte codes
		files		:[],
		ascii		:[],	// ASCII-Graphics memory
	};
	var	trace = {
		callback	:null,
		timer		:null,
		active		:true,
		ready		:true,
		reply		:false,
		step		:false,
		is_port		:false,
		is_context	:false,
		is_debug	:false,
		is_freeze	:true,
		expressions	:["", "", "", "", "", "", "", "", "", ""],
		expression	:0,
		clock		:1024,
		scale		:8192,
		pointer		:0,
		address		:0xF800,
		lines		:67,
		flash		:25,
		halt		:[],
		text		:[],
		labels		:[],	// Assembly idents: address -> name || name -> address
	};
	var	watch = {
		active		:"",
		sAdjust		:"IPC",
		iAdjust		:0,
		nAdjust		:1,
		dirty		:7,
		instructions	:null,
		disassembly	:null,
		registers	:null,
		address		:null,
		mnemonic	:null,
		remark		:null,
		context		:null,
		c2d		:null,
		fontCnv		:null,
		fonts		:null,
		fontBit		:null,
	};
	var	$CTX		= null,
		$IP		= 0|0,
		$IE		= 0|0,	// iteration extension mode neo:[1:Skip; 2:Loop; 3:Wait]
		$IR		= 0|0,	// iterative register
		$IT		= 0|0,	// iteration tick
		$IB		= 0|0,	// immediate data
		$IV		= 0|0,	// immediate signed data value
		$IW		= 0|0,	// immediate signed wide value
		$EV		= 0|0;	// event value
	var	DO_OVERHEAD	= 0,
		DO_ACCLAIM	= 1,
		DO_BUFFER	= 2,
		DO_CONTEXT	= 3,
		DO_DEVICE	= 4,
		DO_ERROR	= 5,
		DO_FORCE	= 6,
		DO_GARRET	= 7;
	var	i, j;
	var	irq		= -1;
	var	ram;
	var	ctx		= new Array(16);
	var	cr		= [-1, 0, 0, 0, 0, 0, 0, 0];
	var	user		= {};
	var	display		= function() {};
	var	hTimer		= null;
	this.$EV = $EV;
	this.DO_OVERHEAD	= DO_OVERHEAD;
	this.DO_ACCLAIM		= DO_ACCLAIM;
	this.DO_BUFFER		= DO_BUFFER;
	this.DO_CONTEXT		= DO_CONTEXT;
	this.DO_DEVICE		= DO_DEVICE;
	this.DO_ERROR		= DO_ERROR;
	this.DO_FORCE		= DO_FORCE;
	this.DO_GARRET		= DO_GARRET;
	//
	Number.prototype.Hex = function(n) {
		return	(n < 0 ? "0x" : "") + ((((this >> 16) & 0x0000FFFF) | 0x00010000).toString(16) + ((this & 0x0000FFFF) | 0x00010000).toString(16).substr(1)).substr(-Math.abs(n)).toUpperCase();
	}
	Number.prototype.hi = function(n) {
		if(isFinite(n))
			return (this & 0x00FF) | ((n & 0x00FF) << 8);
		return (this >> 8) & 0x00FF;
	}
	Number.prototype.lo = function(n) {
		if(isFinite(n))
			return (this & 0xFF00) | (n & 0x00FF);
		return this & 0x00FF;
	}
	Number.prototype.hl = function(hi, lo) {
		return	(lo & 0x00FF) | ((hi & 0x00FF) << 8);
	}
	String.prototype.Mul = function(n, j) {var s = this, buf = ""; while(n > 0) { if(n&1) buf+=s; s+=(j?j:"")+s; n >>= 1; } return buf; }
	Array.prototype.Dump = function(a, n) {
		var	s = [], m, t = "__", d = "INT 0|INT 1|INT 2|INT 3|INT 4|INT 5|INT 6|INT 7|INT 8|INT 9|AX-File(AL:AH)|BX-File(BL:BH)|CX-File(CL:CH)|DX-File(DL:DH)|SP/BP/SI/DI|IP/JP|Services Masking".split("|");
		if(isFinite(a))
			while(n --)
				s.push(this[a ++ & 0xFFFF].Hex(2));
		else {
			n = this.length;
			m = microdis();
			for(a = 0; a < 16; ++ a)
				t += " ." + a.Hex(1);
			for(a = 0; a < n; ++ a) {
				s.push(this[a].Hex(2));
				if((a & 15) == 15)
					if(a >= 0xE0 && a <= 0xEF)
						t += "\r\n" + (a & 0xF0).Hex(2) + ":" + s.slice(0, 2).join(" ") + "/" + s.slice(2, 4).join(" ") + "/" + s.slice(4, 6).join(" ") + "/" + s.slice(6, 8).join(" "),
						t += "|" + s.slice(8, 10).join(" ") + "/" + s.slice(10, 12).join(" ") + "/" + s.slice(12, 14).join(" ") + "/" + s.slice(14, 16).join(" ") + ";" + d.shift(),
						s = [];
					else
						t += "\r\n" + (a & 0xF0).Hex(2) + ":" + s.slice(0, 8).join(" ") + "|" + s.slice(8, 16).join(" ") + ";" + d.shift() + (a > 16 && a <= 0x7F ? "|" + m.shift() : ""),
						s = [];
			}
			for(a = 0; a < 8; ++ a)
				s.push(cr[a].Hex(2));
			t += "\r\n+0:" + s.join(" ") + ";" + d.shift();
			return t;
		}
		return s.join(" ");
	}
	this.IRQ = function(type) {
		cr[1] |= 1 << (type & 7);
		if((cr[0] & 0xF) > 0) {
			log("!/IRQ %d", type & 7);
			cr[0] &= 0xF0;
			HEAP(IP());
			HEAP(AX());
			FH(type | 8);
			FL(7);
			IPnext(JP(0));
		}
	}
	//
	function log() {
		if(trace.active && arguments) {
			var	args = Array.prototype.slice.call(arguments);
			var	level = args[0].charAt(0);
			var	group = args[0].replace(/^[!#@]?/, "\1" + _CPU_ID_).split("/");
			for(var i = 1; i < group.length; ++ i)
				console.group(group[i - 1]);
			args.shift();
			args.unshift(group.pop())
			switch(level) {
			case	"!":
				console.warn.apply(this, args)
				break;
			case	"#":
				console.info.apply(this, args)
				break;
			case	"@":
				console.error.apply(this, args)
				break;
			default:
				if(trace.active)
					console.log.apply(this, args)
				break;
			}
			while(i --)
				console.groupEnd();
		}
	}
	function CTW(index, address, data) {
		index &= 0xF;
		address &= 0xFF;
		if(isFinite(data))
			ctx[index][address] = data.lo(),
			ctx[index][address ^ 8] = data.hi();
		return	Number().hl(ctx[index][address ^ 8], ctx[index][address ^ 0]);
	}
	function CR(index, data) {
		//log("!/CR:%s %s", index, data);
		if(isFinite(index)) {
			index &= 7;
			if(isFinite(data)) {
				if(((data & 0x0F) != (cr[0] & 0xF)) && (index == 0))
					$CTX = ctx[data & 15], $IE = 0, $IR = 0,
					trace.expressions = ["", "", "", "", "", "", "", "", "", ""];
				return	cr[index] = data & 0xFF;
			}
			return	cr[index];
		}
		return	cr[0] & 0xF;
	}
	function CTX(index, data) {
		//log("/CTX(%d, %d)", index, data);
		if(isFinite(data))
			ctx[(cr[0] >> 4) & 15][index & 0xFF] = data & 0xFF;
		return	ctx[(cr[0] >> 4) & 15][index & 0xFF];
	}
	function ACC(data) {	// Holded register
		var	index = (ctx[CR()][0xA8] >> 4) & 7;
		index = 0xA8 + (index & 3) * 16 - (index & 4) * 2;
		if(isFinite(data))
			data &= 0xFF,
			$CTX[index] = data;
		else
			data = $CTX[index];
		return	data;
	}
	function REG(index, data) {// Register[AH,BH,CH,DH,AL,BL,CL,DL]
		index &= 7;
		index = 0xA8 + (index & 3) * 16 - (index & 4) * 2;
		if(isFinite(data))
			data &= 0xFF,
			$CTX[index] = data;
		else
			data = $CTX[index];
		return	data;
	}
	function DST(data) {	// Holded pointer
		var	index = ($CTX[0xA8] >> 4) & 7;
		if(index & 4)
			index = 0xA0 + 16 * (index & 3);
		else
			index = 0xE0 + index;
		if(isFinite(data))
			data &= 0xFFFF,
			$CTX[index] = data.lo(),
			$CTX[index + 8] = data.hi();
		else
			data = Number().hl($CTX[index + 8], $CTX[index]);
		return	data;
	}
	function PTR(index, data) {// Pointer[SP,BP,SI,DI,AX,BX,CX,DX]
		index &= 7;
		if(index & 4)
			index = 0xA0 + 16 * (index & 3);
		else
			index = 0xE0 + index;
		if(isFinite(data))
			data &= 0xFFFF,
			$CTX[index] = data.lo(),
			$CTX[index + 8] = data.hi();
		else
			data = Number().hl($CTX[index + 8], $CTX[index]);
		return	data;
	}
	function DROP(index) {
		if(!isFinite(index))
			index = $CTX[0xA8];
		index &= 7;
		index = 0xA8 + (index & 3) * 16 - (index & 4) * 2;
		$CTX.splice(index + 7, 0, $CTX.splice(index, 1)[0]);
		return	$CTX[index + 7];
	}
	function DUP(index) {
		if(!isFinite(index))
			index = $CTX[0xA8];
		index &= 7;
		index = 0xA8 + (index & 3) * 16 - (index & 4) * 2;
		$CTX.splice(index + 7, 1), $CTX.splice(index, 0, $CTX[index]);
		return	$CTX[index + 7];
	}
	function JP(index, address) {
		index &= 1;
		if(isFinite(address))
			$CTX[0xFE + index] = address.hi(),
			$CTX[0xF6 + index] = address.lo();
		else
			address = Number().hl($CTX[0xFE + index], $CTX[0xF6 + index]);
		return	address & 0xFFFF;
	}
	function IP(address) {
		if(isFinite(address))
			$CTX.splice(0xF3, 1), $CTX.splice(0xF0, 0, address.lo()),
			$CTX.splice(0xFB, 1), $CTX.splice(0xF8, 0, address.hi()),
			address = Number().hl($CTX[0xF9], $CTX[0xF1]);
		else
			address = Number().hl($CTX[0xF8], $CTX[0xF0]);
		return	address & 0xFFFF;
	}
	function IPnext(address) {
		var	further;
		if(isFinite(address))
			further = address;
		else
			address = Number().hl($CTX[0xF8], $CTX[0xF0]),
			further = address + 1;
		$CTX[0xF0] = further.lo(), $CTX[0xF8] = further.hi();
		return	address & 0xFFFF;
	}
	function SP(address) {
		if(isFinite(address) && trace.is_freeze)
			$CTX[0xE0] = address.lo(), $CTX[0xE8] = address.hi();
		else
		if(isFinite(address))
			$CTX.splice(0xE1, 1), $CTX.splice(0xE0, 0, address.lo()),
			$CTX.splice(0xE9, 1), $CTX.splice(0xE8, 0, address.hi()),
			address = Number().hl($CTX[0xE8], $CTX[0xE0]);
		else
			address = Number().hl($CTX[0xE8], $CTX[0xE0]);
		return	address & 0xFFFF;
	}
	function SPnext() {
		var	address = Number().hl($CTX[0xE8], $CTX[0xE0]),
			further = address + 1;
		$CTX[0xE0] = further.lo(), $CTX[0xE8] = further.hi();
		return	address & 0xFFFF;
	}
	function SPback() {
		var	address = Number().hl($CTX[0xE8], $CTX[0xE0]),
			further = address - 1;
		$CTX[0xE0] = further.lo(), $CTX[0xE8] = further.hi();
		return	address & 0xFFFF;
	}
	function _SP_(data) {
		var	address = Number().hl($CTX[0xE8], $CTX[0xE0]);
		if(isFinite(data))
			DW(address, data);
		else
			data = DW(address);
		return	data;
	}
	function HEAP(data) {
		var	address = Number().hl($CTX[0xE8], $CTX[0xE0]);
		if(isFinite(data))
			DW(address -= 2, data);
		else
			data = DW(address),
			address += 2;
		$CTX[0xE0] = address.lo(), $CTX[0xE8] = address.hi();
		return	data;
	}
	function BP(address) {
		if(isFinite(address) && trace.is_freeze)
			$CTX[0xE2] = address.lo(), $CTX[0xEA] = address.hi();
		else
		if(isFinite(address))
			$CTX.splice(0xE3, 1), $CTX.splice(0xE2, 0, address.lo()),
			$CTX.splice(0xEB, 1), $CTX.splice(0xEA, 0, address.hi());
		else
			address = Number().hl($CTX[0xEA], $CTX[0xE2]);
		return	address & 0xFFFF;
	}
	function SI(address) {
		if(isFinite(address) && trace.is_freeze)
			$CTX[0xE4] = address.lo(), $CTX[0xEC] = address.hi();
		else
		if(isFinite(address))
			$CTX.splice(0xE5, 1), $CTX.splice(0xE4, 0, address.lo()),
			$CTX.splice(0xED, 1), $CTX.splice(0xEC, 0, address.hi());
		else
			address = Number().hl($CTX[0xEC], $CTX[0xE4]);
		return	address & 0xFFFF;
	}
	function DI(address) {
		if(isFinite(address) && trace.is_freeze)
			$CTX[0xE6] = address.lo(), $CTX[0xEE] = address.hi();
		else
		if(isFinite(address))
			$CTX.splice(0xE7, 1), $CTX.splice(0xE6, 0, address.lo()),
			$CTX.splice(0xEF, 1), $CTX.splice(0xEE, 0, address.hi());
		else
			address = Number().hl($CTX[0xEE], $CTX[0xE6]);
		return	address & 0xFFFF;
	}
	function AX(address) {
		if(isFinite(address) && trace.is_freeze)
			$CTX[0xA0] = address.lo(), $CTX[0xA8] = address.hi();
		else
		if(isFinite(address))
			$CTX.splice(0xAF, 1), $CTX.splice(0xA0, 0, address.lo()), $CTX[0xA8] = address.hi();
		else
			address = Number().hl($CTX[0xA8], $CTX[0xA0]);
		return	address & 0xFFFF;
	}
	function BX(address) {
		if(isFinite(address) && trace.is_freeze)
			$CTX[0xB0] = address.lo(), $CTX[0xB8] = address.hi();
		else
		if(isFinite(address))
			$CTX.splice(0xBF, 1), $CTX.splice(0xB0, 0, address.lo()), $CTX[0xB8] = address.hi();
		else
			address = Number().hl($CTX[0xB8], $CTX[0xB0]);
		return	address & 0xFFFF;
	}
	function _BX_(data) {
		if(isFinite(data))
			DB(Number().hl($CTX[0xB8], $CTX[0xB0]), data);
		else
			data = DB(Number().hl($CTX[0xB8], $CTX[0xB0]));
		return	data;
	}
	function CX(address) {
		if(isFinite(address) && trace.is_freeze)
			$CTX[0xC0] = address.lo(), $CTX[0xC8] = address.hi();
		else
		if(isFinite(address))
			$CTX.splice(0xCF, 1), $CTX.splice(0xC0, 0, address.lo()), $CTX[0xC8] = address.hi();
		else
			address = Number().hl($CTX[0xC8], $CTX[0xC0]);
		return	address & 0xFFFF;
	}
	function DX(address) {
		if(isFinite(address) && trace.is_freeze)
			$CTX[0xD0] = address.lo(), $CTX[0xD8] = address.hi();
		else
		if(isFinite(address))
			$CTX.splice(0xDF, 1), $CTX.splice(0xD0, 0, address.lo()), $CTX[0xD8] = address.hi();
		else
			address = Number().hl($CTX[0xD8], $CTX[0xD0]);
		return	address & 0xFFFF;
	}
	function _AL_(data) {
		if(isFinite(data))
			$CTX.splice(0xA7, 1), $CTX.splice(0xA0, 0, data.lo());
		else
			data = $CTX[0xA0];
		data -= (data & 0x80) << 1;
		return	data & 0xFFFF;
	}
	function AL(data) {
		if(isFinite(data) && trace.is_freeze)
			$CTX[0xA0] = data & 0xFF;
		else
		if(isFinite(data))
			$CTX.splice(0xA7, 1), $CTX.splice(0xA0, 0, data.lo());
		else
			data = $CTX[0xA0];
		return	data & 0x00FF;
	}
	function AH(data) {
		if(isFinite(data) && trace.is_freeze)
			$CTX[0xA8] = data & 0xFF;
		else
		if(isFinite(data))
			$CTX.splice(0xAF, 1), $CTX.splice(0xA8, 0, data.lo());
		else
			data = $CTX[0xA8];
		return	data & 0x00FF;
	}
	function BL(data) {
		if(isFinite(data) && trace.is_freeze)
			$CTX[0xB0] = data & 0xFF;
		else
		if(isFinite(data))
			$CTX.splice(0xB7, 1), $CTX.splice(0xB0, 0, data.lo());
		else
			data = $CTX[0xB0];
		return	data & 0x00FF;
	}
	function BH(data) {
		if(isFinite(data) && trace.is_freeze)
			$CTX[0xB8] = data & 0xFF;
		else
		if(isFinite(data))
			$CTX.splice(0xBF, 1), $CTX.splice(0xB8, 0, data.lo());
		else
			data = $CTX[0xB8];
		return	data & 0x00FF;
	}
	function CL(data) {
		if(isFinite(data) && trace.is_freeze)
			$CTX[0xC0] = data & 0xFF;
		else
		if(isFinite(data))
			$CTX.splice(0xC7, 1), $CTX.splice(0xC0, 0, data.lo());
		else
			data = $CTX[0xC0];
		return	data & 0x00FF;
	}
	function CH(data) {
		if(isFinite(data) && trace.is_freeze)
			$CTX[0xC8] = data & 0xFF;
		else
		if(isFinite(data))
			$CTX.splice(0xCF, 1), $CTX.splice(0xC8, 0, data.lo());
		else
			data = $CTX[0xC8];
		return	data & 0x00FF;
	}
	function DL(data) {
		if(isFinite(data) && trace.is_freeze)
			$CTX[0xD0] = data & 0xFF;
		else
		if(isFinite(data))
			$CTX.splice(0xD7, 1), $CTX.splice(0xD0, 0, data.lo());
		else
			data = $CTX[0xD0];
		return	data & 0x00FF;
	}
	function DH(data) {
		if(isFinite(data) && trace.is_freeze)
			$CTX[0xD8] = data & 0xFF;
		else
		if(isFinite(data))
			$CTX.splice(0xDF, 1), $CTX.splice(0xD8, 0, data.lo());
		else
			data = $CTX[0xD8];
		return	data & 0x00FF;
	}
	function FL(data) {
		if(isFinite(data) && trace.is_freeze)
			$CTX[0xA8] = ($CTX[0xA8] & 0xF0) | (data & 0x0F);
		else
		if(isFinite(data))
			$CTX.splice(0xAF, 1), $CTX.splice(0xA8, 0, ($CTX[0xA8] & 0xF0) | (data & 0x0F));
		else
			data = $CTX[0xA8];
		return	data & 0x000F;
	}
	function FH(data) {
		if(isFinite(data) && trace.is_freeze)
			$CTX[0xA8] = ($CTX[0xA8] & 0x0F) | ((data << 4) & 0xFF);
		else
		if(isFinite(data))
			$CTX.splice(0xAF, 1), $CTX.splice(0xA8, 0, ($CTX[0xA8] & 0x0F) | (data << 4).lo());
		else
			data = $CTX[0xA8] >> 4;
		return	data & 0x000F;
	}
	function ADC(data, bits) {
		var	flags;	// SF PF CF ZF
		data = data.lo() + bits.lo() + ((FL() >> 1) & 1);
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 7) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:ADC");
		return	data + (flags << 8);
	}
	function SBB(data, bits) {
		var	flags;	// SF PF CF ZF
		data = data.lo() - bits.lo() - ((FL() >> 1) & 1);
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 7) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:SBB");
		return	data + (flags << 8);
	}
	function ADD(data, bits) {
		var	flags;	// SF PF CF ZF
		data = data.lo() + bits.lo();
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 7) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:ADD");
		return	data + (flags << 8);
	}
	function SUB(data, bits) {
		var	flags;	// SF PF CF ZF
		data = data.lo() - bits.lo();
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 7) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:SUB");
		return	data + (flags << 8);
	}
	function AND(data, bits) {
		var	flags;	// SF PF CF ZF
		data = data.lo() & bits.lo();
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= FL() & 2;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:AND");
		return	data + (flags << 8);
	}
	function OR(data, bits) {
		var	flags;	// SF PF CF ZF
		data = data.lo() | bits.lo();
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= FL() & 2;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:OR");
		return	data + (flags << 8);
	}
	function XOR(data, bits) {
		var	flags;	// SF PF CF ZF
		data = data.lo() ^ bits.lo();
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= FL() & 2;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:XOR");
		return	data + (flags << 8);
	}
	function CMP(bits, data) {
		var	flags;	// SF PF CF ZF
		data = bits.lo() - data.lo();
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 7) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:CMP");
		return	bits.lo() + (flags << 8);
	}
	function NOT(data) { // Bitwise not
		var	flags;	// SF PF CF ZF
		data = data.lo() ^ 0xFF;
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 7) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:NOT");
		return	data + (flags << 8);
	}
	function RAR(data) { // Roll Arithmetic Right
		var	flags;	// SF PF CF ZF
		data = (data.lo() >> 1) | ((data & 1) << 8) | (data & 0x80);
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 7) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:RAR");
		return	data + (flags << 8);
	}
	function RCL(data) { // Roll Cyclic Left
		var	flags;	// SF PF CF ZF
		data = (data.lo() << 1) | ((data >> 7) & 1);
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 7) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:RCL");
		return	data + (flags << 8);
	}
	function RCR(data) { // Roll Cyclic Right
		var	flags;	// SF PF CF ZF
		data = (data.lo() >> 1) | ((data & 1) << 7);
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 6) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:RCR");
		return	data + (flags << 8);
	}
	function ROL(data) { // Roll Overflow Left
		var	flags;	// SF PF CF ZF
		data = (data.lo() << 1) | ((FL >> 1) & 1);
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 7) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:ROL");
		return	data + (flags << 8);
	}
	function ROR(data) { // Roll Overflow Right
		var	flags;	// SF PF CF ZF
		data = (data.lo() >> 1) | ((data & 1) << 8) | ((FL & 2) << 7);
		flags = data ^ (data >> 4);
		flags ^= flags << 2;
		flags ^= flags >> 1;
		flags &= 4;
		flags |= (data >> 7) & 2;
		data &= 0xFF;
		flags |= (((data ^ 0xFF) + 1) >> 8) & 1;
		flags |= (data >> 4) & 8;
		//log("ALU:ROR");
		return	data + (flags << 8);
	}
	var	FileIndex = 0;
	var	FileSeek = 0;
	var	Value = 0;
	var	Resume = 0;
	var	FileMode = 0;
/*			cpu.preset.files.push({
				name	:file.id.substr(5),
				text	:file.innerText,
				code	:{
					name	:"",
					begin	:65535,
					end	:0,
					bin	:[]
				}
*/	function PORT(index, data) {
		if(cr[0] & 0x0F) {
/*			if(isFinite(data))
				console.log("!/OUTPUT %s,%s", index.Hex(2), data.Hex(2));
			else
				console.log("!/INPUT %s", index.Hex(2));
*/			if(isFinite(data)) {
				if(ctx[0][0x80]) {
					trace.ready = true;
					ctx[0][0x80] = 0;
					return	data;
				}
				ctx[0][0xA2] = index & 0xFF,
				ctx[0][0xA1] = data & 0xFF;
				$EV = DO_DEVICE;
				return	index;
			} else {
				console.log("!/INPUT %s %s ", index.Hex(2), $EV);
				trace.ready = false;
				if(ctx[0][0x80]) {
					trace.ready = true;
					ctx[0][0x80] = 0;
					return	ctx[0][0xA1];
				}
				ctx[0][0xA1] = index & 0xFF,
				$EV = DO_DEVICE;
				return	index;
			}
		}
		if(isFinite(data))
			log("!/OUT %s,%s", index.Hex(2), data.Hex(2));
		else
			log("!/IN %s", index.Hex(2));
		switch(index) {
		case 0xF5:
			if(isFinite(data)) {
				switch(data) {
				case 0xC0: case 0xC1: case 0xC2: case 0xC3: case 0xC4: case 0xC5: case 0xC6: case 0xC7: case 0xC8: case 0xC9: case 0xCA: case 0xCB: case 0xCC: case 0xCD: case 0xCE: case 0xCF:
					Value = ((Value << 4) & 0xFFF0) | (data & 15);
					log("!PORT/FILE/Code %s", data.Hex(2));
					break;
				case 0xD1:
					FileIndex = Value;
					log("!PORT/FILE/File %s", Value.Hex(2));
					break;
				case 0xD5:
					FileSeek = Value;
					log("!PORT/FILE/Seek %s", Value.Hex(2));
					break;
				case 0xD3:
					FileMode = Value;
					log("!PORT/FILE/Mode %s", Value.Hex(2));
					break;
				}
				Resume = -1;
				trace.ready = true;
			} else {
				trace.ready = true;
				switch(FileMode) {
				case 0:
					Resume = Resume >= 0 ? Resume : preset.files.length;
					data = Resume & 255;
					Resume >>= 8;
					log("!PORT/FILE/Get File Number");
					break;
				case 1:
					Resume = Resume >= 0 ? Resume : 0;
					data = preset.files[FileIndex].code.name.charCodeAt(Resume);
					Resume ++;
					log("!PORT/FILE/Get File Name");
					if(Resume >= preset.files[FileIndex].code.name.length)
						trace.ready = false;
					break;
				case 2:
					Resume = Resume >= 0 ? Resume : preset.files[FileIndex].begin;
					data = Resume & 255;
					Resume >>= 8;
					log("!PORT/FILE/Get File Start");
					break;
				case 3:
					Resume = Resume >= 0 ? Resume : preset.files[FileIndex].end;
					data = Resume & 255;
					Resume >>= 8;
					log("!PORT/FILE/Get File End");
					break;
				case 4:
					Resume = Resume >= 0 ? Resume : preset.files[FileIndex].code.begin;
					data = preset.files[FileIndex].code.bin[Resume];
					log("!PORT/FILE/Get File Data");
					if(Resume < preset.files[FileIndex].code.end)
						++ Resume;
					else
						trace.ready = false;
					break;
				}
			}
			break;
		case 0xFD:
			if(isFinite(data)) {
			} else {
				if(document.getElementById("KeyBoard").value == "")
					trace.ready = false,
					data = 255;
				else {
					data = document.getElementById("KeyBoard").value.charCodeAt(0), document.getElementById("KeyBoard").value = document.getElementById("KeyBoard").value.substr(1);
					trace.ready = true;
					if(data == 0x60) {
						data = document.getElementById("KeyBoard").value.charCodeAt(0), document.getElementById("KeyBoard").value = document.getElementById("KeyBoard").value.substr(1);
						if(data > 0x40 && data <= 0x5F)
							data &= 0x1F;
						else
							data = 0x7F;
					}
				}
			}
			break;
		default:
			data = 0;
		}
		return	data;
	}
	function DB(addr, data) {
		if(isFinite(data)) {
			addr &= 0xFFFF,
			data &= 0xFF;
			if(trace.is_context && trace.is_port) {
				log("#/CONTROL:%s <= %s", addr.Hex(2), data.Hex(2));
				if(cr[0] & 15) {
					cr[1] |= 1 << 0;
					log("!/IRQ %d", type & 7);
					IPnext($IP);
					cr[0] = ((cr[0] << 4) & 0xF0);
					HEAP(IP());
					HEAP(AX());
					FH(type | 8);
					FL(7);
					IPnext(JP(0));
				}
				cr[addr & 7] = data;
				trace.is_context = false;
				trace.is_port = false;
			} else
			if(trace.is_context) {
				log("#/CONTEXT:%s <= %s", addr.Hex(2), data.Hex(2));
				trace.is_context = false;
				trace.is_port = false;
			} else
			if(trace.is_port) {
				log("#/PORT:%s <= %s", addr.Hex(2), data.Hex(2));
				trace.is_port = false;
				data = PORT(addr.lo(), data);
			} else {
				trace.ready = true;
				ram[addr] = data;
			}
		} else {
			if(isFinite(addr))
				addr &= 0xFFFF;
			else
			if(trace.is_context || trace.is_port) {
				log("@/:TEST IP = %s ERROR", IP().Hex(4));
				trace.is_debug = true;
				trace.is_context = false;
				trace.is_port = false;
				data = Math.random() & 0xFF;
				return	data;
			} else
				addr = IPnext();
			if(trace.is_context && trace.is_port) {
				data = cr[addr & 7];
				log("#/CONTROL:%s <= %s", addr.Hex(2), data.Hex(2));
				trace.is_context = false;
				trace.is_port = false;
				if(cr[0] & 15) {
					log("!/IRQ %d", type & 7);
					IPnext($IP);
					cr[0] = ((cr[0] << 4) & 0xF0);
					HEAP(IP());
					HEAP(AX());
					FH(type | 8);
					FL(7);
					IPnext(JP(0));
				}
			} else
			if(trace.is_context) {
				data = 0x55;
				log("#/CONTEXT:%s <= %s", addr.Hex(2), data.Hex(2));
				trace.is_context = false;
				trace.is_port = false;
				data = 0x55;
			} else
			if(trace.is_port) {
				data = PORT(addr.lo());
				log("#/PORT:%s => %s", addr.Hex(2), data.Hex(2));
				trace.is_port = false;
			} else {
				trace.ready = true;
				data = ram[addr].lo();
			}
		}
		return	data;
	}
	function DW(addr, data) {
		if(isFinite(data)) {
			addr &= 0xFFFF,
			data &= 0xFFFF;
			ram[addr ++] = data.lo();
			data &= 0xFFFF;
			ram[addr] = data.hi();
		} else {
			data = ram[addr ++ & 0xFFFF];
			data = Number().hl(ram[addr & 0xFFFF], data);
		}
		return	data;
	}
	this.$CTX = $CTX;
	this.CTW = CTW;
	this.CTX = CTX;
	this.CR = CR;
	this.ACC = ACC;
	this.DST = DST;
	this.PTR = PTR;
	this.REG = REG;
	this.DROP = DROP;
	this.DUP = DUP;
	this.JP = JP;
	this.IP = IP;
	this.IPnext = IPnext;
	this.SP = SP;
	this.SPnext = SPnext;
	this.SPback = SPback;
	this._SP_ = _SP_;
	this.HEAP = HEAP;
	this.BP = BP;
	this.SI = SI;
	this.DI = DI;
	this.AX = AX;
	this.BX = BX;
	this._BX_ = _BX_;
	this.CX = CX;
	this.DX = DX;
	this._AL_ = _AL_;
	this.AL = AL;
	this.BL = BL;
	this.CL = CL;
	this.DL = DL;
	this.AH = AH;
	this.BH = BH;
	this.CH = CH;
	this.DH = DH;
	this.FL = FL;
	this.FH = FH;
	this.ADC = ADC;
	this.SBB = SBB;
	this.ADD = ADD;
	this.SUB = SUB;
	this.AND = AND;
	this.OR = OR;
	this.XOR = XOR;
	this.CMP = CMP;
	this.NOT = NOT;
	this.RAR = RAR;
	this.RCL = RCL;
	this.RCR = RCR;
	this.ROL = ROL;
	this.ROR = ROR;
	this.PORT = PORT;
	this.DB = DB;
	this.DW = DW;
	function flags(d) {
		var	fx = AH();
		if(!isFinite(d)) {
			var	d = fx;
			s = AL().Hex(2) + " " + AH().Hex(2) + "(AX)" + "----------- USING_BH/BP USING_CH/SI USING_DH/DI USE_AL/[SP] USING_BL/BX USING_CL/CX USING_DL/DX ??????????? INDEX_OF_x1 INDEX_OF_x2 INDEX_OF_x3 INDEX_OF_x4 INDEX_OF_x5 INDEX_OF_x6 INDEX_OF_x7".split(" ")[(d >> 4) & 15].replace(/_/g, " ");
			switch(fx & 0xF) {
			case 0x5:	s += "|SKIP:Missed";	break;
			case 0x7:	s += "|SKIP:MISSED";	break;
			case 0x9:	s += "|LOOP:Cycled";	break;
			case 0xB:	s += "|LOOP:CYCLED";	break;
			case 0xD:	s += "|WAIT:Ready ";	break;
			case 0xF:	s += "|WAIT:Holded";	break;
			default:
				s += "|sf pf cf zf".replace(/.f/g, function(str) {
					str = d & 0x08 ? str.toUpperCase() : str.toLowerCase();
					d <<= 1;
					return str;
				});
			}
			d = (fx >> 4) & 15;
			d = d < 8 ? REG(d) : d + 248;
			//s += ("|EXx" + (d & 256 ? "#" + d.Hex(1) : d.Hex(2)) + ":" + (isFinite(this.r.ex[d]) ? this.r.ex[d].Hex(2) : "--"));
			/*s += (" JPx" + this.r.jp.Hex(4));
			s += (" SXx" + this.r.asx[(this.r.ax & 0x8000 ? 248 + (this.r.ax >> 12) : this.reg(this.r.ax >> 12)) % 264].Hex(4));
			s += (" TXx" + this.r.atx[(this.r.ax & 0x8000 ? 248 + (this.r.ax >> 12) : this.reg(this.r.ax >> 12)) % 264].Hex(4));
			s += (" SRx" + this.r.sr.Hex(4));*/
			return s;
		}
		fx =	((d << 3) & 0x0400) |
			(d & 255 ? 0 : 0x100) |
			((d << 1) & 0x0200);
		d ^= d >> 4;
		d ^= d << 2;
		d ^= d << 1;
	}
	this.reset = function(address) {
		log("!/CORE:RESET");
		CR(0, 0);
		IPnext(address);
		$CTX[0xA8] = 0xF7;
		trace.pointer = address;
		trace.active = true;
		trace.freeze = true;
		clearTimeout(hTimer);
		step.bind(this).call();
	}
	function	step() {
		"use asm"
		var	ic	= 0|0,	// instruction prefix/code
			code	= 0|0,	// instruction selected code
			action	= 0|0,	// instruction actions
			scale	= 0|0,
			i	= 0|0,
			tmp	= 0|0,
			ctrl,
			tick	= 0|0;
		hTimer = setTimeout(this.step.bind(this), 1000 / trace.clock);
		scale = !trace.active || trace.step ? trace.step ? 1 : trace.scale : 0;
		if((trace.step && !trace.active && !trace.halt[IP()]))
			trace.active = true,
			disassm();
		if((!trace.step && !trace.active && trace.halt[IP()]))
			disassm();
		if(tmp = CR())
			tick = Number().hl(cr[7], cr[6]) & 0xFFFF;
		else
			tick = -1;
		$EV = -DO_CONTEXT;
		try {
			while(!!(($IP = IP()) || (ready = true)) && (trace.step || (!trace.halt[$IP] && !trace.active)) && (scale -- > 0) && ((tick != 0) && tick --) && ($EV < 0)) {
				trace.is_port = false;
				trace.is_context = false;
				$IB = $IV = $IW = 0;
				$IR = $IT = FH();
				$IR &= $IR & 8 ? 0 : 15;
				$IT &= $IT & 8 ? 15 : 0;
				$IE = FL();
				if(!!($IE >> 2) && !!($IE & 1))
					$IE >>= 2;
				else
					$IE = 0;
				ic = DB();
				if(((ic >> 4) == (ic & 0x0F)) && (ic < 0x80) && !!ic)
					ic = ((ic & 0x07) << 8) | DB();
				if((ic & 0xC0) == 0x80)
					$IB = DB(),
					$IV = $IB - (($IB & 0x0080) << 1),
					$IW = $IV + ((ic & 0x0700) - ((ic & 0x0400) << 1));
				ctrl = !(cr[0] & 0x0F) && ($IE == 3) && ((ic.lo() == 0) || ((ic.hi() * 0x11) == ic.lo()));
				//log("!/CLR (ic.lo = %d) || (ic.hi = %d) == %s ", ic.lo(), ic.hi(), tmp);
				if($IT && $IE && !ctrl) {
					i = -- $IT;
					if(i == 8)
						FL(FL() & 0xE),
						FH(0),
						$IT = $IE == 1 || $IE == 3 ? 8 : 0,
						$IE = $IE == 1 || $IE == 3 ? $IE : 0;
					else
						FH(i);
				} else
				if(($IT == 8) && !ctrl)
					FH(0),
					$IT = !ctrl ? 0 : 8;
				else
				if($IR && !REG($IR) && !ctrl)
					$IE = 0;
				code = preset.instructions[ic];
				if(code && code.expression) {
					trace.is_freeze = (!!$IR || !!$IT) && !!$IE || !(cr[0] & 0x0F) || !(ctx[0][0xA8] & 0x02);
					//trace.is_freeze = true;
					if(ctrl) {
						code.envelope(this, $IP, $IB, $IV, $IW, $IE, $IR, $IT);
						//log("!/CLR (ic.lo = %d) || (ic.hi = %d) ", ic.lo(), ic.hi());
							$IE = 0,
//							$IT = 0,
							$IR = 0;
							if(CR() == 0)
								FL(FL() & 0xE);
						//trace.expression = "";
					} else
					if($IT != 8 && $IE != 1) {
						ctrl = FL() & 0x0D;
						if(((ic & 0xFF) >= 0xF0) && ((ic & 0xFF) <= 0xF9) && ($IE == 3)) {
							trace.expression = ic & 0x0F;
							if(ic >= 0x100) {
								tmp = ((ic & 0xF) << 4) + 15;
								i = ((ic >> 7) & 14) + 1;
								while(i < 14)
									$CTX[++ i] = 0,
									$CTX[++ i] = 0;
								while(tmp & 14)
									$CTX[tmp] = $CTX[tmp -- & 15],
									$CTX[tmp] = $CTX[tmp -- & 15];
								FL(FL() & 0xE);
								$IE = 0;
								trace.expressions[ic & 15] = "";
							} else {
								if(trace.expressions[ic & 15] == "") {
									tmp = ((ic & 0xF) << 4) + 15;
									while(!$CTX[tmp] && !$CTX[tmp - 1] && (tmp & 14))
										tmp -= 2
									while(tmp & 14) {
										$IB = $CTX[tmp --];
										action = $CTX[tmp --] + (($IB << 3) & 0x700);
										$IV = ($IB & 31) - ($IB & 16) * 2;
										$IW = $IB - ($IB & 128) * 2;
										$IB &= 255;
										trace.expressions[ic & 15] += preset.instructions[action].expression
											.replace(/(\$IB)/g, "" + $IB)
											.replace(/(\$IV)/g, "" + $IV)
											.replace(/(\$IW)/g, "" + $IW) + ";\r\n";
									}
									//log("!/EVAL %s", trace.expression);
								}
								trace.is_freeze = true;
								eval(trace.expressions[ic & 15]);
								if(($IT != 8) && (!$IR || (REG($IR) != 1)))
									trace.ready = !trace.ready;
								//$EV = this.DO_CONTEXT;
								//log("!/%d %d %d", it, ir, REG(ir));
							}
						} else {
							//if($IE == 3)
							//	$EV = this.DO_DEVICE;//scale = -scale;
							code.envelope(this, $IP, $IB, $IV, $IW, $IE, $IR, $IT);
							//trace.expression = "";
						}
						tmp = FL();
						if($IE == 2 || $IE == 3)
							FL((tmp & 0x2) | ctrl);
					} else
						$CTX.splice(0x0E, 2),
						$CTX.splice(0x02, 0, (ic & 0xFF), ((ic >> 3) & 0xE0) | ($IV & 0x1F));
					if($IE != 0) {
						if((!!$IR || !!$IT) && ($IE == 2))
							//log("!/LOOP %d %s %s", it, $IP, $IP.Hex(4)),
							IPnext($IP);
						else
						if((!!$IR || !!$IT) && ($IE == 3)) {
							//log("!/WAIT %d %s %s - %s %s", it, $IP, $IP.Hex(4), FL().Hex(2), trace.ready);
							if(!!(FL() & 2) == !!trace.ready) {
								IPnext($IP);
							} else
								//log("!/CLEAR FL"),
								FL(FL() & 0x0E);
						}
						if(!$IR && !$IT)
							if(!!(FL() >> 2) && !!(FL() & 1))
								FL(FL() & 0x0E);
							else
								FL(tmp);
					}
				}
				if($IR) {
					if((i = REG($IR)) && $IE >= 1)
						REG($IR, -- i);
					if(i == 0 && $IE >= 1)
						FL(FL() & 0xE);
				}
/*			if(tick < 2 && CR()) {
				trace.active = true;
				break;
			}
*/			}
		} catch(e) {
			trace.active = true;
			log("@/CORE/%s %s %s:%s ($IV:%s $IW:%s) %s\r\n%s", $IP.Hex(4), ic.Hex(3), $IB.Hex(2), code.instruction, $IV.Hex(2), $IW.Hex(4), e, code.expression);
		}
		if(CR()) {
			//log("!TASK#%d", CR());
			if(tick == 0 || $EV >= 0) {
				$EV = $EV < 0 ? -$EV : +$EV;
				switch($EV) {
				case	this.DO_OVERHEAD:log("!/CORE OVERHEAD");break;
				case	this.DO_ACCLAIM	:log("!/CORE ACCLAIM");	break;
				case	this.DO_BUFFER	:log("!/CORE BUFFER");	break;
				case	this.DO_CONTEXT	:log("!/CORE CONTEXT");	break;
				case	this.DO_DEVICE	:log("!/CORE DEVICE");	break;
				case	this.DO_ERROR	:log("!/CORE ERROR");	break;
				case	this.DO_FORCE	:log("!/CORE FORCE");	break;
				case	this.DO_GARRET	:log("!/CORE GARRET");	break;
				}
				cr[1] |= 1 << $EV;
				CR(0, CR(0) & 0xF0);
				FL(0x5), FH(0x8 | $EV);
			}
		}
		if(tick >= 0)
			//log("!/CORE tick"),
			cr[6] = tick.lo(),
			cr[7] = tick.hi();
		trace.step = false;
		trace.pointer = IP();
		if(watch.active == "")
			disassm();
	}
	this.CR = CR;
	this.step = step;
	this.ram = function(handle, data) {
		var	ok = false;
		var	addr;
		if(isFinite(handle) && typeof handle == "number") {
			addr = handle;
			if(isFinite(data)) {
				log("#/RAM/[%04X]=%02X", addr, data);
				return	ram[addr & 0xFFFF] = data;
			} else {
				data = DB(addr);
				log("#/RAM/[%04X]:%02X", addr, data);
				return	data;
			}
		} else
		if(handle) {
			try {
				ram = handle;
				for(addr = 0; addr < 65536; ++ addr)
					trace.halt[addr] = false,
					ram[addr] = isFinite(data) ? data : Math.random() * 256 & 0x97;
				log("#/RAM/Initializing successful for %d bytes", addr);
				ok = true;
			} catch(e) {
				log("@/Initializing crashed... %d", 5);
			}
		} else
			return	ram;
		if(!ok)
			throw new Error("654");
		return	true;
	}
	function command_set(prefix, large) {
		if(prefix && typeof prefix != "number")
			return	user.command_table = prefix;
		var	ic, ib,
			i = 0,
			dump = [],
			Instructions = [],
			operands = [],
			Operation, Instruction, Operands;
		if(isFinite(prefix))
			prefix = isFinite(prefix) ? (prefix & 7) << 8 : 0,
			ic = -1,
			ib = -1;
		else {
			dump = watch.address.value.replace(/[0-9A-F]{4}/g, "").match(/([0-9A-F]{2})/g);
			if(!dump)
				return;
			dump.push(0, 0);
			ic = parseInt(dump.shift(), 16);
			if(ic && ic < 0x80 && (ic & 15) == (ic >> 4))
				prefix = (ic & 7) << 8,
				ic = parseInt(dump.shift(), 16),
				ib = parseInt(dump.shift(), 16);
			else
				ib = parseInt(dump.shift(), 16),
				prefix = 0;
			dump = [];
		}
		for(code = 0; code < 256; ++ code) {
			Operation = preset.instructions[prefix + code];
			Instruction = Operation.instruction + " ".Mul(7);
			Operands = Operation.operands;
			len = Operands.length - 7;
			if(len > 0)
				Instruction = Instruction.substr(0, 7 - len) + Operands,
				Operands = Operands.substr(-7);
			Instruction += "       ",
			Operands += "       ";
			over = "";
//			if(Operation.expression.indexOf("// ") >= 0)
	//			over = " title='" + Operation.expression.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") + "'";
//				over = Operation.expression.substr(3 + Operation.expression.indexOf("// ")) + ((code >> 4) == (code & 15) && !(code & 8) && !prefix ? "\r\n[ALT+" + (code & 7) + "]" :"") + "\r\n";
			if(large)
				over = " onmouseover='document.getElementById(\"Context\").innerText=cpu.preset.instructions[" + (prefix+code) + "].expression'";
			html = "<span title='" + over + "'class=CPU_Group_" + Operation.color + " " + ((code >> 4) == (code & 15) && code < 0x80 ? "onclick='cpu.command_set(" + (code & 7) + "," + large + ")'" : "") + over + ">#</span>";
			Instruction = Instruction.substr(0, 7);
			Operands = Operands.substr(0, 7).replace(/(?:\$)(\+[1-7])/, function(str, high) {
				high = parseInt(high);
				return	high < 4 ? "$+" + high : "$" + (high - (high & 4) * 2);
			}).replace(/(\+)(IB)/, "\xB1$2");
			Instructions.push(html.replace("#", (ic == code ? "<b style=background-color:white><u style=color:black>" + Instruction + "</u></b>" : Instruction)));
			operands.push(html.replace("#", (ic == code ? "<b style=background-color:white><u style=color:black>" + Operands.replace("IB", ib.Hex(2)) + "</u></b>" : Operands)));
			if((code & 15) == 15)
				dump.push("&#x2551;" + ((large || code <= 0x10 ? "" : "<span style=text-decoration:overline>") + (code >> 4).Hex(1) + "&#x2551;" + Instructions.join("&#x2502;") + (large ? "" : "</span>") + "&#x2551;<br />")
					+ ("&#x2551; &#x2551;"+ operands.join("&#x2502;") + "&#x2551;").replace(/(IB|XX)/g, "<b style=color:cyan>$1</b>")),
				Instructions = [], operands = [];
		}
		prefix >>= 8;
		for(code = 0; code < 16; ++ code)
			operands.push("&#x255D;" + code.Hex(1) + "&#x255A;&#x2550;&#x2550;&#x2550;&#x2550;");
		watch.instructions.innerHTML = (prefix ? (prefix * 0x11).Hex(2) + "+" : "   ") + "&#x2554;&#x2550;&#x2557;     ".Mul(16) + "<br />" +
			"&#x2554;&#x2550;&#x2566;" + operands.join("&#x2564;") + "&#x2557;<br />" +
			dump.join(large ? "<br />&#x255F;&#x2500&#x256B;" + "&#x2500;".Mul(7).Mul(16, "&#x253C;") + "&#x2562;<br />" : "<br />") +
			"<br />&#x255A;&#x2550;&#x2569" + "&#x2550".Mul(7).Mul(16, "&#x2567") + "&#x255D";
	}
	this.preset=preset;
	//////// Assembler ///////////////////////////////////////////
	this.assembly = function(listing, files) {
		var	text = listing.split(/\r?\n/),
			line, part, regs, args, code, regz, regy, regw,
			val_nnIB, val_sxIB, val_s_IB,
			instr, ins,
			tmp,
			dbg = true,	// Debug mode
			hlt = false,	// Halting flag
			arg, val,
			rego, cnt,
			regas, regaz, regay, regaw, regao,
			ip, ipx,
			labels = {},	// All labels
			label,		// Current label
			labelz = {},
			laps = 3,
			lap = laps,
			prc = 0,
			prcs = text.length * laps,
			title = document.title,
			file = {
				name	:"",
				begin	:65535,
				end	:0,
				bin	:[]
			},
			bin	= !files ? ram : file.bin;
		log("!/ASSM/START");
		do {
			ip = -1; label = [];
			for(line in text) {
				++ prc;
				if(files && !lap && ip >= 0 && file.begin > ip)
					file.begin = ip;
				part = text[line];
				part = /([^:;"'`\s]*(?::| ?))?(?:\s)*([^\s;]*)(?:\s*)([^\s,;"'`]*)(?:[,\s]*)?([^\s,;"'`]*)(?:[,\s]*)?(?:(?:("(?:\\.|.)*?")|('(?:\\.|.)*?')|(`(?:\\.|.)*?`)|[^;"'`]*)*)*(\.*)/.exec(part);
				if(part[1]) {
					part[1] = part[1].replace(/[ :]$/, "");
					tmp = part[1].replace(/:/g, "..").match(/(\.*)(.*)/);
					label = label.slice(0, tmp[1].length).concat(tmp[2].split("."));
					part[1] = label.join(".");
					if(trace.labels[part[1]] != ip)
						delete trace.labels[trace.labels[part[1]]];
					trace.labels[ip] = part[1],
					trace.labels[part[1].toUpperCase()] = ip;
					/*labelz = {};
					cnt = 1 << 8;
					do {
						var	idn = "";
						for(var id in trace.labels)
							if((id.length > idn.length) && (id.substr(-1) != " ") && !labelz[id])
								idn = id;
							else
								continue;
							//idn = (id.length > idn.length) && (id.substr(-1) != " ") && !labelz[id] ? id : idn;
						if(idn != "")
							labelz[idn] = trace.labels[idn];
					} while((cnt --) && (idn != ""));*/
				}
				instr = part[2].toUpperCase();
				if(instr.substr(-1) == "?" || instr.substr(-1) == "!") {
					if((dbg || (instr.substr(-1) == "!")) && !lap)
						trace.halt[ip] = true;
					instr = instr.substr(0, instr.length - 1);
				}
				regs = [part[2], part[3]].join(" ").toUpperCase();
				if(part[4])
					regs += "," + part[4].toUpperCase();
				if((regs = preset.alias[regs]) || (regs = preset.alias[instr])) {
					regs = regs.split(" ");
					for(var i in regs) {
						if(typeof(regs[i]) == "string")
							ram[ip ++] = parseInt(regs[i], 16);
					}
					continue;
				}
				part[3] = part[3].replace(/^(\.+)/, function(str, data) {
					var	data = data.length;
					return label.slice(0, data).join(".") + ".";
				});
				part[4] = part[4].replace(/^(\.+)/, function(str, data) {
					var	data = data.length;
					return label.slice(0, data).join(".") + ".";
				});
				regs = part[3];
				if(part[4])
					regs += "," + part[4];
				args = [];
				try{
					regs = regs.replace(/(\.*)([A-Z_a-z][A-Z_a-z.0-9]*)/g, function(str, nest, tag) {
						var	tmp = trace.labels[label.slice(0, nest.length).concat(tag.split(".")).join(".").toUpperCase()];
						//console.log(ip.Hex(4) + " " +str + "::" + nest + ":" + tag + "=" + tmp);
						if(isFinite(tmp))
							return Number(tmp).Hex(-4);
						return	nest + tag;
					});
				/*for(var i in labelz) {
					regs = regs.replace(new RegExp("("+i.replace(/(\.)/g, "\\.")+")", "gi"), function(str, data) {
						return "0x" + Number(labelz[i]).Hex(4);
					});
				}*/
				}catch(e){}
				rego = regs; ipx = false;
				regs = regs.replace(/\$([+-](0x[0-9A-F]+|[0-9]+))/g, function(str, data) {
					ipx = true;
					data = (ip + parseInt(data) - 1) & 0xFFFF;
					args.push(data);
					return "0x" + data.Hex(4);
				});
				regs = regs.replace(/(0x[0-9A-F]+|[0-9]+)(\*|\/)(0x[0-9A-F]+|[0-9]+)+/g, function(str, x, op, y) {
					return	(op == "*" ? parseInt(x) * parseInt(y) : op == "/" && !!parseInt(y) ? parseInt(x) / parseInt(y) : 0x8000).Hex(-4);
				});
				regs = regs.replace(/(0x[0-9A-F]+|[0-9]+)([+-])(0x[0-9A-F]+|[0-9]+)+/g, function(str, x, op, y) {
					return	(op == "+" ? parseInt(x) + parseInt(y) : parseInt(x) - parseInt(y)).Hex(-4);
				});
				regs = regs.replace(/([-+](0x[0-9A-F]+|[0-9]+))/g, function(str, data) {
					return "+" + (parseInt(data) + 256).Hex(-2);
				});
				ins = preset.mnemonics[instr];
				code = -1;
				if(ins && (regs in ins))
					code = ins[regs];
				else {
					arg_nnIB = regs.replace(/(0x[0-9A-F]+)|([0-9]+)/gi, function(str, data) {	// nnIB
						var	bin0 = parseInt(data);
						var	tag0 = regs.replace(/\+(0x[0-9A-F]+|[0-9]+)/, "+IB");
						var	bin1 = parseInt(data);
						var	tag1 = bin1.hi().Hex(2) + "IB";
						var	bin2 = parseInt(data) + (ipx ? -ip- 3 : -ip - 2);
						var	tag2 = "$+IB";
						var	bin3 = parseInt(data) + (ipx ? -ip- 4 : -ip - 3);
						var	bin3a = bin3 + (bin3 < -128 ? +(bin3 & 0x80) * 2 : bin3 >= 128 ? +(bin3 & 0x80) * 2 : 0);
						var	tag3 = "$+" + ((bin3a >> 8) & 7) + "IB";
						if(ins) {
							if(tag0 in ins)
								return	args.push(bin0) ? "IB" : "IB";
							if(tag1 in ins)
								return	args.push(bin1) ? tag1 : tag1;
							if(bin2 >= -128 && bin2 < 128 && (tag2 in ins))
								return	args.push(bin2.lo()) ? tag2 : tag2;
							if(((bin3 >= -1024 && bin3 < -128) || (bin3 >= 128 && bin3 <= 895)) && (tag3 in ins))
								return	args.push(bin3.lo()) ? tag3 : tag3;
							if("IB" in ins)
								return	args.push(bin1) ? "IB" : "IB";
							if(part[4] && (regs.split(",")[0] + ",IB") in ins)
								return	(code = ins[part[3] + ",IB"]) && args.push(bin1) ? "" : "";
							if("" in ins)
								return	"";
						}
						args.push(bin1);
						return "";
					});
					if(ins && (arg_nnIB in ins))
						code = ins[arg_nnIB];
					else
					if(part[4] && ins && ([part[4].toUpperCase(), part[3].toUpperCase()].join(",") in ins))
						code = ins[[part[4].toUpperCase(), part[3].toUpperCase()].join(",")];
					else
					if(part[4] && ins && (part[3].toUpperCase() in ins) && (part[4].toUpperCase() in ins))
						code = ins[part[3].toUpperCase()] | (ins[part[4].toUpperCase()] << 16);
					else
					if(ins && (part[3].toUpperCase() in ins))
						code = ins[part[3].toUpperCase()];
					else
					if(part[4] && ins && (regs.toUpperCase() in ins))
						code = ins[regs.toUpperCase()];
					else
					if(ins && ((arg_nnIB = arg_nnIB.replace(/(\[[A-Z]{2})(\])/ig, "$1+IB$2")) in ins))
						code = ins[arg_nnIB], args.unshift(0);
				}
				switch(instr) {
				case	"FILE":	file.name = regs;						continue;
				case	"DEBUG":dbg = !!parseInt(regs);						continue;
				case	"ORG":	ip = args.shift();						continue;
				case	"EQU":	labels[part[1].toUpperCase()] = args.shift();			continue;
				case	"BRK":	if(files && dbg && !lap) trace.halt[ip] = !!parseInt(regs);	continue;
				case	"DB":
					if(part[5]) {
						args = part[5].replace(/Ё/ig, "Е").replace(/[абвгдеёжзийклмнопрстуфхцчшщъыьэюя]/ig, function(str, ascii) {
							var	koi7ru = "ЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ",
								data = koi7ru.indexOf(ascii);
							if(data < 0)
								return ascii;
							return String.fromCharCode(ascii + 0x60);
						}).split("");
						args.shift(); args.pop();
						while(args.length) {
							tmp = args.shift();
							code = tmp.charCodeAt(0);
							if(tmp == "\\")
								switch(tmp = args.shift()) {
								case	'0':	code = 0x00; break;
								case	't':	code = 0x09; break;
								case	'n':	code = 0x0A; break;
								case	'h':	code = 0x0C; break;
								case	'r':	code = 0x0D; break;
								case	'e':	code = 0x1B; break;
								case	'_':	code = 0x1F; break;
								case	'<':	code = 0x08; break;
								case	'>':	code = 0x18; break;
								case	'^':	code = 0x19; break;
								case	'v':	code = 0x1A; break;
								default:	code = tmp.charCodeAt(0);
								}
							trace.text[ip] = true,
							bin[ip ++] = code;
						}
					} else
						while(args.length)
							trace.text[ip] = true,
							bin[ip ++] = args.shift();
					continue;
				case	"DW":
					while(args.length)
						tmp = args.shift(),
						trace.text[ip] = true,
						bin[ip ++] = tmp.lo(),
						trace.text[ip] = true,
						bin[ip ++] = tmp.hi();
					continue;
				}
				hlt = !lap;
				if(code >= 0) {
					do {
						if(!files)
							trace.halt[ip] &= hlt;
						if(code & 0x700)
							trace.text[ip] = false,
							((bin[ip ++] = ((code >> 8) & 7) * 0x11).Hex(2)),
							trace.halt[ip] = false;
						trace.text[ip] = false,
						((bin[ip ++] = code & 0xFF).Hex(2));
						if(((code & 0x0C0) == 0x080) && args.length > 0)
							trace.text[ip] = false,
							trace.halt[ip] = false,
							((bin[ip ++] = args.shift()).Hex(2));
					} while((code & 0x0800) && (code >>= 16));
				}
				if(files && !lap && ip >= 0 && file.end < end)
					file.end = ip;
				//if(Math.floor(100 * prc / prcs) <= 100)
				//	document.title = Math.floor(100 * prc / prcs) + "%";
			}
		} while(lap --);
		document.title = title;
		log("!/ASSM/FINISH");
		disassm();
		if(files)
			return file;
	}
	function microdis() {
		var	i, ic, ib, z, asm;
		var	cmd = [];
		i = (trace.expression << 4);
		while((i += 2) & 0x0F) {
			ic = $CTX[i] & 0xFF, ib = $CTX[i + 1] & 0xFF;
			ic |= (ib & 0xE0) << 3;
			ib = (ib & 0x1F) - (ib & 0x10) * 2;
			z = preset.instructions[ic];
			asm = (z.instruction + "    ").substr(0, 5) + z.operands;
			asm = asm.replace(/([^$])\+IB/, function(str, ptr, rel) {
				return	ib < 128 ? ptr + "+" + ib : ptr + (ib - 256);
			});
			asm = asm.replace(/([0-9A-F]{2})IB/, "0x$1" + ib.Hex(2));
			asm = asm.replace(/(\$\+)?([0-7]?IB)/, function(str, rel) {//$+0IB $+IB 0IB
				var	data, len = str.length;
				data = (len == 3 || len == 5 ? +(str.substr(-3, 1)) * 256 : 0);
				if(len == 3 || len == 5)
					data = (data - (data & 0x400) * 2) + (ib - (ib & 0x80) * 2);
				else
					data = (data - (data & 0x80) * 2) + (ib - (ib & 0x80) * 2);
				//data -= (len == 3 || len == 5 ? data & 0x400 : len == 2 ? 0 : data & 0x80) * 2;
				//data += (ib - (ib & 128) * 2);// - (len == 2 ? 0 : (ib & 128) * 2);
				return rel ? (i + data).Hex(-4) : data.Hex(len == 3 || len == 5 ? -3 : -2);
			});
			cmd.unshift(asm);
		}
		return	cmd;
	}
	//////// Disassembler ////////////////////////////////////////
	function disassm() {
		var	i, j,
			addr = (trace.pointer &= 0xFFFF),	// active IP
			ip = trace.address & 0xFFFF, lines = trace.lines, next = ip,
			jp,
			alias, walias,
			list = [], lp, width,
			regs = [],
			ips = [],
			lid,	// label id
			ic, ib = 0, ie, asm,
			active = addr.Hex(4) + " " + ram[addr].Hex(2),
			extend = "",
			color,
			rem = "", row, halt,
			cmm = "";
		if(ip > addr)
			ip = trace.address = (addr + 0xFFF0) & 0xFFFF;
		if("PTR".indexOf(watch.active) >= 0) {
			i = 2;
			active = true||this.w.rg < 0 ? " style=background-color:#252>" : this.w.xx == this.r16(this.w.rg) ? " style=background-color:blue>" : " style=background-color:red>";
			if(extend)
				regs.push(extend);
			else
				regs.push((jp = SP()).Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[SP]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = BP(), rem = "BP", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = SI(), rem = "SI", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = DI(), rem = "DI", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			regs.push(AX().Hex(4) + " " + flags());
			jp = BX(), rem = "BX", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = CX(), rem = "CX", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = DX(), rem = "DX", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = IP(), rem = "IP", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - 0, i)+ "</u>[" + rem + "]" + ram.Dump(jp & 0xFFF0, 8) + "|" + ram.Dump((jp & 0xFFF0) + 8, 8) + " " + ram.Text(jp & 0xFFF0, 16));
			//jp = IP() + 16, rem = "IP", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - 0, i)+ "</u>[" + rem + "]" + ram.Dump(jp & 0xFFF0, 8) + "|" + ram.Dump((jp & 0xFFF0) + 8, 8) + " " + ram.Text(jp & 0xFFF0, 16));
			//jp = IP() + 32, rem = "IP", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - 0, i)+ "</u>[" + rem + "]" + ram.Dump(jp & 0xFFF0, 8) + "|" + ram.Dump((jp & 0xFFF0) + 8, 8) + " " + ram.Text(jp & 0xFFF0, 16));
			//jp = IP() + 48, rem = "IP", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - 0, i)+ "</u>[" + rem + "]" + ram.Dump(jp & 0xFFF0, 8) + "|" + ram.Dump((jp & 0xFFF0) + 8, 8) + " " + ram.Text(jp & 0xFFF0, 16));
			regs = regs.concat(ctx[(cr[0] >> 4) & 15].Dump().split(/\r?\n/));
			command_set();
		}
		lines -= regs.length;
		for(i = 0, jp = ip; i < lines - 2 || jp < addr; ++ i) {
			ie = 0;
			ips.push(jp);
			ic = ram[jp], jp = (jp + 1) & 0xFFFF;
			if(ic && ic < 0x80 && (ic & 15) == (ic >> 4))
				ie = ic & 7;
			if(ie)
				ic = ram[jp], jp = (jp + 1) & 0xFFFF;
			if((ic & 0xC0) == 0x80)
				jp = (jp + 1) & 0xFFFF;
		}
		if(ips.length > lines - 2)
			ip = trace.address = ips.pop();
		walias = 0;
		while(lines -- > 0) {
			if(!lines)
				this.DIP = ip, ip = addr & 0xFFFF;
			jp = ip;
			row = [ip.Hex(4)];
			rem = "";
			cmm = [];
			ie = 0;
			if(typeof trace.labels[ip] == "string")
				cmm[1] = trace.labels[ip] + ":";
			if(walias < 1) {
				alias = "";
				walias = 6;
				data = [ram[ip].lo().Hex(2), ram[(ip + 1) & 65535].lo().Hex(2), ram[(ip + 2) & 65535].lo().Hex(2), ram[(ip + 3) & 65535].lo().Hex(2), ram[(ip + 4) & 65535].lo().Hex(2), ram[(ip + 5) & 65535].lo().Hex(2)].join("");
				do {
					if(data in preset.alias) {
						alias = preset.alias[data];
						rem = alias.split(/\t/)[1];
						alias = alias.split(/\t/)[0];
						extend = alias.split(/\s|!/);
						if(extend[1]) {
							extend = extend[1].replace(/(?:\[)([0-7])(?:\])/g, "$1").split(/[\s\t,]/);
							extend.push("--", "--");
							if(rem)
								rem = rem.replace(/\%X/g, extend[0]).replace(/\%Y/g, extend[1]);
							break;
						}
					}
					data = data.substr(0, -- walias * 2);
				} while(walias);
			}
			halt = true && trace.halt[ip];
			lp = ip == addr;
			if(trace.text[ip]) {
				i = 0;
				while(i < 29 && trace.text[ip]) {
					if(ram[ip] < 32 || ram[ip] > 128)
						row.push(ram[ip].Hex(2));
					lp |= ip == addr;
					++ i, ++ ip;
				}
				row.push("..", "..", "..");
				asm = ram.Text(ip - i, i) + String.fromCharCode(0xB7).Mul(29 - i);
				asm = row.slice(0, 4).join("\\") + "|" + asm + "|Text";
				if(lines)
					list.push("<span class=CPU_Group_Z>" + asm + "</span>");
				if(lp)
					active = asm;
				continue;
			}
			ic = ram[ip].lo(), ip = (ip + 1) & 0xFFFF,
			row.push(ic.Hex(2)),
			walias --;
			if(ic && ic < 0x80 && (ic & 15) == (ic >> 4))
				ie = ic & 7,
				lp |= ip == addr,
				halt |= true && trace.halt[ip],
				ic = ram[ip].lo(), ip = (ip + 1) & 0xFFFF,
				row.push(ic.Hex(2)),
				walias --;
			if((ic & 0xC0) == 0x80)
				lp |= ip == addr,
				halt |= true && trace.halt[ip],
				ib = ram[ip].lo(), ip = (ip + 1) & 0xFFFF,
				row.push(ib.Hex(2)),
				walias --;
			z = preset.instructions[(ie << 8) | ic];
			asm = (z.instruction + "    ").substr(0, 5) + z.operands;
			asm = asm.replace(/([^$])\+IB/, function(str, ptr, rel) {
				return	ib < 128 ? ptr + "+" + ib : ptr + (ib - 256);
			});
			asm = asm.replace(/([0-9A-F]{2})IB/, "0x$1" + ib.Hex(2));
			asm = asm.replace(/(\$\+)?([0-7]?IB)/, function(str, rel) {//$+0IB $+IB 0IB
				var	data, len = str.length;
				data = (len == 3 || len == 5 ? +(str.substr(-3, 1)) * 256 : 0);
				if(len == 3 || len == 5)
					data = (data - (data & 0x400) * 2) + (ib - (ib & 0x80) * 2);
				else
					data = (data - (data & 0x80) * 2) + (ib - (ib & 0x80) * 2);
				//data -= (len == 3 || len == 5 ? data & 0x400 : len == 2 ? 0 : data & 0x80) * 2;
				//data += (ib - (ib & 128) * 2);// - (len == 2 ? 0 : (ib & 128) * 2);
				return rel ? (ip + data).Hex(-4) : data.Hex(len == 3 || len == 5 ? -3 : -2);
			});
			if(!cmm[1]) {
				lid = asm.match(/(0x[0-9A-F]{4})/);
				if(lid) {
//					log("!/DIS:%s %s", lid[0], trace.labels[parseInt(lid[0])]);
					if(typeof trace.labels[parseInt(lid[0])] == "string")
						cmm[1] = "(" + trace.labels[parseInt(lid[0])] + ")";
				};
			}
			width = row.length;
			while(row.length < 4)
				row.push("  ");
//			if(!cmm[1])
//				cmm = z.expression.split("// ");
			if(!cmm[1])
				cmm[1] = z.remark;
			if(alias != "") {
				data = alias.split(/[!\s]/);
				asm = asm.split(/\s+/);
				asm = asm.join(" ".Mul(5 - asm[0].length));
				asm = (data[0] + " ".Mul(4)).substr(0, 5) + (data[1] + " ".Mul(7)).substr(0, 7) + ";" + (asm + " ".Mul(16)).substr(0, 16);//, rem = "";
				//asm = (data.replace("!", "") + " ".Mul(7)).substr(0, 9) + (" ".Mul(16) + asm.replace(/\s+/g, " ")).substr(-18), rem = "";
			}
			if(rem == "")
			if(cmm[1]) {
				if(rem.split(" ")[0] == z.instruction)
					asm += "/" + rem.split(" ")[1];
				else
				if(rem)
					asm += " ".Mul(16 - asm.length) + ";" + rem;
				rem = cmm[1];//z.expression.substr(3 + z.expression.indexOf("// "));
			}
			if(walias >= 0 && alias == "")
				asm = row.join(" ") + "|" + " ".Mul(12) + ";" + (asm + " ".Mul(16)).substr(0, 16) + "|" + rem;
			else
				asm = row.join(" ") + "|" + (asm + " ".Mul(29)).substr(0, 29) + "|" + rem;
			alias = "";
			if(lp)
				active = asm;
			color = (watch.dirty || (watch.active == "")) && (walias < 0) ? z.color : "Z";
			asm = "<span class='CPU_Group_" + color + (halt ? " halted" : "") + (lp ? " active" : "") + "' onclick='cpu.trace.halt[" + jp + "] ^= true; cpu.disassm()' ondblclick='cpu.trace.pointer = " + jp + "'>" + asm + "</span>";
//				asm = "<span class='CPU_Group_" + z.color + (halt ? " halted" : "") + (lp ? " active" : "") + " title='style=text-decoration:overline><u'>" + asm + "</span>";
			if(lp) {
/*				if(ie && (ic & 0xEF) == 0xEA) {
					i = (AX() >> 12) & 15;
					i = i < 8 ? this.reg(i) : i + 248;
					extend = (i & 256 ? "EX#" + i.Hex(1) : "Ex" + i.Hex(2)) + " <u>";
					{
						extend += (i >= 256 && i > 257) || (i < 256 && i >= 2) ? this.r.ex[i - 2].Hex(2) + " " : "?? ";
						extend += (i >= 256 && i > 256) || (i < 256 && i >= 1) ? this.r.ex[i - 1].Hex(2) : "??";
						extend += "</u>[RX]";
						for(j = 0; j < 16; ++ j)
							extend += (j ? (j & 0xFF) == 1 ? "|" : " " : "") + ((i < 256 && i + j < 256) || (i >= 256 && i + j < 264) ? this.r.ex[i + j].Hex(2) : "??");
						extend += "  ";
						for(j = 0; j < 16; ++ j)
							extend += String.fromCharCode(i >= 256 | (i + j) > 255 ? 0xB7 : this.r.ex[i + j] >= 32 && this.r.ex[i + j] < 127 ? this.r.ex[i + j] : 0xB7);
					}
				}*/
			}// else	asm = "<span class=CPU_Group_" + z.color + " onclick='document.getElementById(\"DebugAddr\").value=(cpu.DR=" + parseInt(asm, 16) + ").Hex(4)' title='Set break point'>" + asm + "</span>";
			//if(halt)
			//	asm = "<s>" + asm + "</s>";
				//asm = "<span class=prefix onclick='document.getElementById(\"DebugAddr\").value=(cpu.DR=" + parseInt(asm, 16) + ").Hex(4)' title='Set break point'>" + asm + "</span>";
			if(!list.length)
				next = ip;
			if(lines)
				list.push(asm);
		}
		watch.disassembly.innerHTML = list.concat(regs).join("<br />");
		var	inter = active.split("|");
		if(watch.active != "P")
			watch.address.value = inter.shift().replace(/\s+$/, "");
		else
			inter.shift();
		if(watch.active != "T")
			watch.mnemonic.value = inter.shift().replace(/\s+/g, "\t").replace(/\s+(\(.*)?$/, "");
		else
			inter.shift();
		if(watch.active != "R")
			watch.remark.value = inter.shift().replace(/\s+$/, "");
		if(!(watch.active in "01234567".split("")))
			command_set();
		//watch.dirty = true;
	}
	function disassm_old() {
		var	i, j,
			addr = (trace.pointer &= 0xFFFF),	// active IP
			ip = trace.address & 0xFFFF, lines = trace.lines, next = ip,
			jp,
			list = [], lp, width,
			regs = [],
			ips = [],
			lid,	// label id
			ic, ib = 0, ie, asm,
			active = addr.Hex(4) + " " + ram[addr].Hex(2),
			extend = "",
			color,
			rem = "", row, halt,
			cmm = "";
		if(ip > addr)
			ip = trace.address = (addr + 0xFFF0) & 0xFFFF;
		if("PTR".indexOf(watch.active) >= 0) {
			i = 2;
			active = true||this.w.rg < 0 ? " style=background-color:#252>" : this.w.xx == this.r16(this.w.rg) ? " style=background-color:blue>" : " style=background-color:red>";
			if(extend)
				regs.push(extend);
			else
				regs.push((jp = SP()).Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[SP]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = BP(), rem = "BP", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = SI(), rem = "SI", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = DI(), rem = "DI", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			regs.push(AX().Hex(4) + " " + flags());
			jp = BX(), rem = "BX", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = CX(), rem = "CX", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = DX(), rem = "DX", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - i, i)+ "</u>[" + rem + "]" + ram.Dump(jp, 8) + "|" + ram.Dump(jp + 8, 8) + "<u>" + ram.Text(jp - i, i) + "</u>" + ram.Text(jp, 16));
			jp = IP(), rem = "IP", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - 0, i)+ "</u>[" + rem + "]" + ram.Dump(jp & 0xFFF0, 8) + "|" + ram.Dump((jp & 0xFFF0) + 8, 8) + " " + ram.Text(jp & 0xFFF0, 16));
			//jp = IP() + 16, rem = "IP", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - 0, i)+ "</u>[" + rem + "]" + ram.Dump(jp & 0xFFF0, 8) + "|" + ram.Dump((jp & 0xFFF0) + 8, 8) + " " + ram.Text(jp & 0xFFF0, 16));
			//jp = IP() + 32, rem = "IP", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - 0, i)+ "</u>[" + rem + "]" + ram.Dump(jp & 0xFFF0, 8) + "|" + ram.Dump((jp & 0xFFF0) + 8, 8) + " " + ram.Text(jp & 0xFFF0, 16));
			//jp = IP() + 48, rem = "IP", regs.push(jp.Hex(4) + " <u>" + ram.Dump(jp - 0, i)+ "</u>[" + rem + "]" + ram.Dump(jp & 0xFFF0, 8) + "|" + ram.Dump((jp & 0xFFF0) + 8, 8) + " " + ram.Text(jp & 0xFFF0, 16));
			regs = regs.concat(ctx[(cr[0] >> 4) & 15].Dump().split(/\r?\n/));
			command_set();
		}
		lines -= regs.length;
		for(i = 0, jp = ip; i < lines - 2 || jp < addr; ++ i) {
			ie = 0;
			ips.push(jp);
			ic = ram[jp], jp = (jp + 1) & 0xFFFF;
			if(ic && ic < 0x80 && (ic & 15) == (ic >> 4))
				ie = ic & 7;
			if(ie)
				ic = ram[jp], jp = (jp + 1) & 0xFFFF;
			if((ic & 0xC0) == 0x80)
				jp = (jp + 1) & 0xFFFF;
		}
		if(ips.length > lines - 2)
			ip = trace.address = ips.pop();
		while(lines -- > 0) {
			if(!lines)
				this.DIP = ip, ip = addr & 0xFFFF;
			jp = ip;
			row = [ip.Hex(4)];
			rem = "";
			cmm = [];
			ie = 0;
			if(typeof trace.labels[ip] == "string")
				cmm[1] = trace.labels[ip] + ":";
			data = [ram[ip].lo().Hex(2), ram[(ip + 1) & 65535].lo().Hex(2), ram[(ip + 2) & 65535].lo().Hex(2), ram[(ip + 3) & 65535].lo().Hex(2), ram[(ip + 4) & 65535].lo().Hex(2), ram[(ip + 5) & 65535].lo().Hex(2)].join("");
			do {
				if(data in preset.alias) {
					rem = preset.alias[data];
					data = rem.indexOf("!") < 0 ? "" : rem;
					break;
				}
				data = data.indexOf("!") < 0 ? data.substr(0, data.length - 2) : data;
			} while((data != "") && (rem == ""));
			halt = true && trace.halt[ip];
			lp = ip == addr;
			if(trace.text[ip]) {
				i = 0;
				while(i < 23 && trace.text[ip]) {
					if(ram[ip] < 32 || ram[ip] > 128)
						row.push(ram[ip].Hex(2));
					lp |= ip == addr;
					++ i, ++ ip;
				}
				row.push("..", "..", "..");
				asm = ram.Text(ip - i, i) + String.fromCharCode(0xB7).Mul(23 - i);
				asm = row.slice(0, 4).join("\\") + "|" + asm + "|Text";
				if(lines)
					list.push("<span class=CPU_Group_Z>" + asm + "</span>");
				if(lp)
					active = asm;
				continue;
			}
			ic = ram[ip].lo(), ip = (ip + 1) & 0xFFFF;
			row.push(ic.Hex(2));
			if(ic && ic < 0x80 && (ic & 15) == (ic >> 4))
				ie = ic & 7,
				lp |= ip == addr,
				halt |= true && trace.halt[ip],
				ic = ram[ip].lo(), ip = (ip + 1) & 0xFFFF,
				row.push(ic.Hex(2));
			if((ic & 0xC0) == 0x80)
				lp |= ip == addr,
				halt |= true && trace.halt[ip],
				ib = ram[ip].lo(), ip = (ip + 1) & 0xFFFF,
				row.push(ib.Hex(2));
			z = preset.instructions[(ie << 8) | ic];
			asm = (z.instruction + "    ").substr(0, 5) + z.operands;
			asm = asm.replace(/([^$])\+IB/, function(str, ptr, rel) {
				return	ib < 128 ? ptr + "+" + ib : ptr + (ib - 256);
			});
			asm = asm.replace(/([0-9A-F]{2})IB/, "0x$1" + ib.Hex(2));
			asm = asm.replace(/(\$\+)?([0-7]?IB)/, function(str, rel) {//$+0IB $+IB 0IB
				var	data, len = str.length;
				data = (len == 3 || len == 5 ? +(str.substr(-3, 1)) * 256 : 0);
				if(len == 3 || len == 5)
					data = (data - (data & 0x400) * 2) + (ib - (ib & 0x80) * 2);
				else
					data = (data - (data & 0x80) * 2) + (ib - (ib & 0x80) * 2);
				//data -= (len == 3 || len == 5 ? data & 0x400 : len == 2 ? 0 : data & 0x80) * 2;
				//data += (ib - (ib & 128) * 2);// - (len == 2 ? 0 : (ib & 128) * 2);
				return rel ? (ip + data).Hex(-4) : data.Hex(len == 3 || len == 5 ? -3 : -2);
			});
			if(!cmm[1]) {
				lid = asm.match(/(0x[0-9A-F]{4})/);
				if(lid) {
//					log("!/DIS:%s %s", lid[0], trace.labels[parseInt(lid[0])]);
					if(typeof trace.labels[parseInt(lid[0])] == "string")
						cmm[1] = "(" + trace.labels[parseInt(lid[0])] + ")";
				};
			}
			width = row.length;
			while(row.length < 4)
				row.push("  ");
//			if(!cmm[1])
//				cmm = z.expression.split("// ");
			if(!cmm[1])
				cmm[1] = z.remark;
			if(data != "") {
				data = data.split("!");
				asm = (data[0] + "    ").substr(0, 5) + data[1] + (" ".Mul(16) + asm.replace(/\s+/g, " ")).substr(-18), rem = "";
				//asm = (data.replace("!", "") + " ".Mul(7)).substr(0, 9) + (" ".Mul(16) + asm.replace(/\s+/g, " ")).substr(-18), rem = "";
			}
			if(cmm[1]) {
				if(rem.split(" ")[0] == z.instruction)
					asm += "/" + rem.split(" ")[1];
				else
				if(rem)
					asm += " ".Mul(15-6 - asm.length) + ";" + rem;
				rem = cmm[1];//z.expression.substr(3 + z.expression.indexOf("// "));
			}
			asm = row.join(" ") + "|" + (asm + " ".Mul(23)).substr(0, 23) + "|" + rem;
			if(lp)
				active = asm;
			color = watch.dirty || (watch.active == "") ? z.color : "Z";
			asm = "<span class='CPU_Group_" + color + (halt ? " halted" : "") + (lp ? " active" : "") + "' onclick='cpu.trace.halt[" + jp + "] ^= true; cpu.disassm()' ondblclick='cpu.trace.pointer = " + jp + "'>" + asm + "</span>";
//				asm = "<span class='CPU_Group_" + z.color + (halt ? " halted" : "") + (lp ? " active" : "") + " title='style=text-decoration:overline><u'>" + asm + "</span>";
			if(lp) {
/*				if(ie && (ic & 0xEF) == 0xEA) {
					i = (AX() >> 12) & 15;
					i = i < 8 ? this.reg(i) : i + 248;
					extend = (i & 256 ? "EX#" + i.Hex(1) : "Ex" + i.Hex(2)) + " <u>";
					{
						extend += (i >= 256 && i > 257) || (i < 256 && i >= 2) ? this.r.ex[i - 2].Hex(2) + " " : "?? ";
						extend += (i >= 256 && i > 256) || (i < 256 && i >= 1) ? this.r.ex[i - 1].Hex(2) : "??";
						extend += "</u>[RX]";
						for(j = 0; j < 16; ++ j)
							extend += (j ? (j & 0xFF) == 1 ? "|" : " " : "") + ((i < 256 && i + j < 256) || (i >= 256 && i + j < 264) ? this.r.ex[i + j].Hex(2) : "??");
						extend += "  ";
						for(j = 0; j < 16; ++ j)
							extend += String.fromCharCode(i >= 256 | (i + j) > 255 ? 0xB7 : this.r.ex[i + j] >= 32 && this.r.ex[i + j] < 127 ? this.r.ex[i + j] : 0xB7);
					}
				}*/
			}// else	asm = "<span class=CPU_Group_" + z.color + " onclick='document.getElementById(\"DebugAddr\").value=(cpu.DR=" + parseInt(asm, 16) + ").Hex(4)' title='Set break point'>" + asm + "</span>";
			//if(halt)
			//	asm = "<s>" + asm + "</s>";
				//asm = "<span class=prefix onclick='document.getElementById(\"DebugAddr\").value=(cpu.DR=" + parseInt(asm, 16) + ").Hex(4)' title='Set break point'>" + asm + "</span>";
			if(!list.length)
				next = ip;
			if(lines)
				list.push(asm);
		}
		watch.disassembly.innerHTML = list.concat(regs).join("<br />");
		var	inter = active.split("|");
		if(watch.active != "P")
			watch.address.value = inter.shift().replace(/\s+$/, "");
		else
			inter.shift();
		if(watch.active != "T")
			watch.mnemonic.value = inter.shift().replace(/\s+/g, "\t").replace(/\s+(\(.*)?$/, "");
		else
			inter.shift();
		if(watch.active != "R")
			watch.remark.value = inter.shift().replace(/\s+$/, "");
		if(!(watch.active in "01234567".split("")))
			command_set();
		//watch.dirty = true;
	}
	this.display = function(callback) {
		display = callback;
		display(this);
	}
	this.interface = function(controls) {
		watch.instructions	= controls.instructions	|| watch.instructions;
		watch.disassembly	= controls.disassembly	|| watch.disassembly;
		watch.registers		= controls.registers	|| watch.registers;
		watch.address		= controls.address	|| watch.address;
		watch.mnemonic		= controls.mnemonic	|| watch.mnemonic;
		watch.remark		= controls.remark	|| watch.remark;
		watch.context		= controls.context	|| watch.context;
	}
	//////////////////////////////////////
	this.command_set = command_set;
	this.disassm = disassm;
	this.JP = JP;
	this.trace = trace;
	this.watch = watch;
	this.log = log;
	this.ctx = ctx;
	this.preset = preset;
	//////////////////////////////////////
	i = ctx.length;
	while(i --) {
		ctx[i] = new Array(j = 256);
		while(j --)
			ctx[i][j] = Math.random() * 0*256 & 255;
	}
	log("!/POWER/CONTEXT[%d]", ctx.length);
	if(description) {
		var	instructions = /^([0X1]{14})([A-F_X])\t([^:+\t]+)(\+?)\t*([^:\t]*?)\t*:(.*)$/gm;
		var	Registers = [], Logics = [];
		var	text = [];
		var	schema = description;
		schema = schema.replace(/^ASCx([0-9A-F]{4})(( ([0-9A-F]{2})){16})/gm, function(str, address, bytes) {
			var	addr = parseInt(address, 16);
			bytes.substr(1).split(" ").forEach(function(code) {
				preset.ascii[addr ++] = parseInt(code, 16);
			});
			return	"";
		});
		schema = schema.replace(/^([A-Z]+[0-9 A-Z\[,\]!]*)\t+?\@([0-9A-F\s\t]+?(\t.*)?)$/gm, function(str, alias, instr) {
			preset.alias[alias.replace(/(!)(.)/, " $2").replace(/!/, "")] = instr.replace(/\t.*/, "");
			instr = instr.split(/\t+/);
			preset.alias[instr[0].replace(/\s+/g, "")] = alias + (instr[1] ? "\t" + instr[1] : "");
			//console.log(alias + "=" + instr + " / (" + alias.replace(/(!)(.)/, " $2").replace(/!/, "") + ")");
			return "";
		});
		schema = schema.replace(/^([^\s]{1,13})\t(.*)$/gm, function(str) {
			var	str = str.split(/\t+/);
			Registers[str[0]] = str[1];
			if(str[3])
				Logics[str[0] + "!"] = str[3];
			if(str[2])
				Logics[str[0]] = str[2];
			text.push([str].join("\t"));
			return "";
		});
		schema.replace(instructions, function(str, pattern, color, Instruction, Few, Operands, Expression) {
			var	bits = [],
				chop = 0,
				laps = 1,
				counter, code,
				mask = parseInt(pattern.replace(/X/g, function(str, position, digits) {
					bits.unshift(1 << (digits.length - position - 1));
					chop |= position < 2 ? bits[0] : 0;
					laps <<= 1;
					return "0";
					}), 2);
			for(var lap = 0; lap < laps; ++ lap) {
				counter = bits.length,
				code = mask;
				while(counter --)
					code |= (lap >> counter) & 1 ? bits[counter] : 0;
				var	_z = 0x07 & (code >> 8),
					_y = 0x07 & (code >> 4),
					_x = 0x07 & (code >> 0),
					locker = code & 0x80
						? ((0x3EA80 >> (_y & 2)) >> (_x << 1)) & (code & 8 ? 3 : 0) | (_x > 1 && _x < 6 && _y < 4 ? 4 : 0)
						: (((_x == _y ? 0 : 3) | (_z == 0 ? 0 : _x == _z ? 0 : _x > _z ? 1 : _z > _x ? 2 : 3)) | (_x < _y ? 4 : 0)),
					helpers = {
					"#T":	((code >> 8) & 7) * 10 + (code & 15),
					"#U":	((code >> 8) & 7) ? ((_z - (_z & 4) * 2) & 7).Hex(1) : "",
					"#V":	(((code >> 8) & 7) * 16 ^ (code & 15) ^ ((code & 16) ? 0xF0 : 0x00)).Hex(2),
					"#W":	((code >> 0) & 31).Hex(2),
					"#X":	((code >> 0) & 7),
					"#Y":	((code >> 4) & 7),
					"#Z":	((code >> 8) & 7)
					};
				if(!preset.instructions[code & 0x07FF] && (/*chop || */((code >> 11) == locker))) {
					var	instruction = Instruction,
						operands = Operands,
						expression = Expression;
					for(counter in helpers) {
						var	alias = new RegExp(counter, "g");
						instruction = instruction.replace(alias, helpers[counter]),
						operands = operands.replace(alias, helpers[counter]),
						expression = expression.replace(alias, helpers[counter]);
					}
					for(counter in Registers)
						instruction = instruction.replace(new RegExp(counter, "g"), Registers[counter]),
						operands = operands.replace(new RegExp(counter, "g"), Registers[counter]);
					for(counter in Logics) {
						var	logic = Logics[counter];
						if(typeof logic == "string") {
							for(var cnt in helpers) {
								var	alias = new RegExp(cnt, "g");
								logic = logic.replace(alias, helpers[cnt]);
							}
						}
						expression = expression.replace(new RegExp(counter, "g"), logic);
					}
					//console.log(expression);
					preset.instructions[code & 0x07FF] = {
						color		: color,
						instruction	: instruction,
						operands	: operands,
						expression	: expression.replace(/\s*\/\/.*/, ""),
						envelope	: new Function("_, $IP, $IB, $IV, $IW, $IE, $IR, $IT", "with(_) {" + expression.replace(/\s*\/\/.*/, ";} return true;")),
						remark		: expression.replace(/^.*?\/\/\s(.*)/, "$1")
					};
					if(!preset.mnemonics[instruction])
						preset.mnemonics[instruction] = [];
					preset.mnemonics[instruction][operands] = (code & 0x07FF) | (Few ? 0x0800 : 0x0000);
					text.push([color, (code & 0x0FFF).Hex(4), instruction, operands, expression].join("\t"));
				}
			}
		});
		var	w, h, c, b, j, x, y, z, p, q, d, a;
		watch.fontCnv = document.createElement("canvas");
		watch.fontCnv.width = 256 * 8 * 2;
		watch.fontCnv.height = 16 * 8 * 2;
		watch.fonts = watch.fontCnv.getContext("2d");
		watch.fontBit = watch.fonts.getImageData(0, 0, watch.fontCnv.width, watch.fontCnv.height);
		d = watch.fontBit.data;
		w = watch.fontCnv.width;
		q = w * 4 * 8;
		for(i = 0; i < 256; ++ i) {
			x = i * 16;
			for(y = 0; y < 8; ++ y) {
				a = preset.ascii[i * 8 + y];
				p = (x + y * w + 7) * 4;
				for(z = 0; z < 8; ++ z, p -= 4, a >>= 1) {
					b = a & 1 ? 0 : 0xFF000000;
					c = a & 1 ? 0xFF000000 : 0;
					d[p + q * 0 + 0] = (c >> 0) & 255; d[p + q * 1 + 0] = (b >> 0) & 255;
					d[p + q * 0 + 1] = (c >> 8) & 255; d[p + q * 1 + 1] = (b >> 8) & 255;
					d[p + q * 0 + 2] = (c >> 16) & 255; d[p + q * 1 + 2] = (b >> 16) & 255;
					d[p + q * 0 + 3] = (c >> 24) & 255; d[p + q * 1 + 3] = (b >> 24) & 255;
					b = a & 1 ? 0 : 0xFF0000FF;
					c = a & 1 ? 0xFF0000FF : 0;
					d[p + q * 2 + 0] = (c >> 0) & 255; d[p + q * 3 + 0] = (b >> 0) & 255;
					d[p + q * 2 + 1] = (c >> 8) & 255; d[p + q * 3 + 1] = (b >> 8) & 255;
					d[p + q * 2 + 2] = (c >> 16) & 255; d[p + q * 3 + 2] = (b >> 16) & 255;
					d[p + q * 2 + 3] = (c >> 24) & 255; d[p + q * 3 + 3] = (b >> 24) & 255;
					b = a & 1 ? 0 : 0xFF00FF00;
					c = a & 1 ? 0xFF00FF00 : 0;
					d[p + q * 4 + 0] = (c >> 0) & 255; d[p + q * 5 + 0] = (b >> 0) & 255;
					d[p + q * 4 + 1] = (c >> 8) & 255; d[p + q * 5 + 1] = (b >> 8) & 255;
					d[p + q * 4 + 2] = (c >> 16) & 255; d[p + q * 5 + 2] = (b >> 16) & 255;
					d[p + q * 4 + 3] = (c >> 24) & 255; d[p + q * 5 + 3] = (b >> 24) & 255;
					b = a & 1 ? 0 : 0xFF00FFFF;
					c = a & 1 ? 0xFF00FFFF : 0;
					d[p + q * 6 + 0] = (c >> 0) & 255; d[p + q * 7 + 0] = (b >> 0) & 255;
					d[p + q * 6 + 1] = (c >> 8) & 255; d[p + q * 7 + 1] = (b >> 8) & 255;
					d[p + q * 6 + 2] = (c >> 16) & 255; d[p + q * 7 + 2] = (b >> 16) & 255;
					d[p + q * 6 + 3] = (c >> 24) & 255; d[p + q * 7 + 3] = (b >> 24) & 255;
					b = a & 1 ? 0 : 0xFFFF0000;
					c = a & 1 ? 0xFFFF0000 : 0;
					d[p + q * 8 + 0] = (c >> 0) & 255; d[p + q * 9 + 0] = (b >> 0) & 255;
					d[p + q * 8 + 1] = (c >> 8) & 255; d[p + q * 9 + 1] = (b >> 8) & 255;
					d[p + q * 8 + 2] = (c >> 16) & 255; d[p + q * 9 + 2] = (b >> 16) & 255;
					d[p + q * 8 + 3] = (c >> 24) & 255; d[p + q * 9 + 3] = (b >> 24) & 255;
					b = a & 1 ? 0 : 0xFFFF00FF;
					c = a & 1 ? 0xFFFF00FF : 0;
					d[p + q * 10 + 0] = (c >> 0) & 255; d[p + q * 11 + 0] = (b >> 0) & 255;
					d[p + q * 10 + 1] = (c >> 8) & 255; d[p + q * 11 + 1] = (b >> 8) & 255;
					d[p + q * 10 + 2] = (c >> 16) & 255; d[p + q * 11 + 2] = (b >> 16) & 255;
					d[p + q * 10 + 3] = (c >> 24) & 255; d[p + q * 11 + 3] = (b >> 24) & 255;
					b = a & 1 ? 0 : 0xFFFFFF00;
					c = a & 1 ? 0xFFFFFF00 : 0;
					d[p + q * 12 + 0] = (c >> 0) & 255; d[p + q * 13 + 0] = (b >> 0) & 255;
					d[p + q * 12 + 1] = (c >> 8) & 255; d[p + q * 13 + 1] = (b >> 8) & 255;
					d[p + q * 12 + 2] = (c >> 16) & 255; d[p + q * 13 + 2] = (b >> 16) & 255;
					d[p + q * 12 + 3] = (c >> 24) & 255; d[p + q * 13 + 3] = (b >> 24) & 255;
					b = a & 1 ? 0 : 0xFFFFFFFF;
					c = a & 1 ? 0xFFFFFFFF : 0;
					d[p + q * 14 + 0] = (c >> 0) & 255; d[p + q * 15 + 0] = (b >> 0) & 255;
					d[p + q * 14 + 1] = (c >> 8) & 255; d[p + q * 15 + 1] = (b >> 8) & 255;
					d[p + q * 14 + 2] = (c >> 16) & 255; d[p + q * 15 + 2] = (b >> 16) & 255;
					d[p + q * 14 + 3] = (c >> 24) & 255; d[p + q * 15 + 3] = (b >> 24) & 255;
				}
			}
		}
		watch.fonts.putImageData(watch.fontBit, 0, 0);
	}
};
/*
80..87:
*/
var	Reset = 0,
	Source = "";
var	cpu;
var	cnv;
var	c2d;
var	img;
var	date = new Date();

function display(core) {
	var	row = [], ram, i, p, h, w, x, y, cx = -1, cy = -1, c, d, u, f = 7, g = 0, col = 7, gnd = 0, s = "";
	var	oldSeconds = date.getSeconds();
	date = new Date();
	var	ms = (date.getMilliseconds() % 500 > 250);
//	if(date.getSeconds() != oldSeconds)
//		core.IRQ(core.DO_EVENTS);
	setTimeout(display, 1000 / cpu.trace.flash, cpu);
	ram = core.ram();
	cx = ram[0x76CF].lo(), cy = ram[0x76CE].lo();
	if(document.getElementById("Display").style.display != "none") {
		w = 78, h = 30;
		x = 0, y = 0, p = 0x76D0;
		f <<= 4, g <<= 4;
		while(y < h) {
			c = ram[p];
			d = c & 255;
			if(d >= 0x80 && d <= 0x87)
				f = (c & 7) << 4;
			if(d >= 0x90 && d <= 0x97)
				g = (c & 7) << 4;
			d = x == cx && y == cy ? 0 : 8;
			if(c < 255 || d == 0) {
				c &= 255;
				d = ms ? d | 8 : d;
				core.watch.c2d.drawImage(core.watch.fontCnv, c * 16 + 2, 8 ^ g ^ d, 6, 8, x * 6, y * 8, 6, 8),
				core.watch.c2d.drawImage(core.watch.fontCnv, c * 16 + 2, 0 ^ f ^ d, 6, 8, x * 6, y * 8, 6, 8);
				ram[p] = ms || !d ? c : c | 256;
			}
			if(++ x >= w)
				f = 7 << 4,
				g = 0 << 4,
				x = 0,
				++ y;
			++ p;
		}
		for(i = 0, w = 78, h = 30, x, y, c, u; i < w * h * 0; ++ i) {
			x = i % w, y = Math.floor(i / w);
			c = ram[(i + 0x76D0) & 0xFFFF];
			d = c & 255;
			if(d > 0x80 && d < 0x87)
				col = d & 7;
			if(d > 0x90 && d < 0x97)
				gnd = d & 7;
			f = 16 * col;
			g = 16 * gnd;
			f ^= x == cx && y == cy ? 0 : 8;
			g ^= x == cx && y == cy ? 0 : 8;
			if(c < 256 || (x == cx && y == cy))
				f ^= c < 256 ? 0 : 8,
				g ^= c < 256 ? 0 : 8,
				core.watch.c2d.drawImage(core.watch.fontCnv, d * 16 + 2, 8 ^ g, 6, 8, x * 6, y * 8, 6, 8),
				core.watch.c2d.drawImage(core.watch.fontCnv, d * 16 + 2, 0 ^ f, 6, 8, x * 6, y * 8, 6, 8);
			ram[(i + 0x76D0) & 0xFFFF] = d | (x != cx || y != cy ? 0 : 256);
		}
	} else {
		for(i = 0, w = 78, h = 30, x, y, c, u; i < w * h * 0; ++ i)
			x = i % w, y = Math.floor(i / w),
			c = ram[(i + 0x76D0) & 0xFFFF],
			ram[(i + 0x76D0) & 0xFFFF] = (c | 256),
			u = c < 256 ? "<span style=color:red>" : (c &= 255, "<span>"),
			row[y] = (x ? row[y] : "") + u +
				(x == ram[0x76CF].lo() && y == ram[0x76CE].lo() && (new Date()).getMilliseconds() % 500 > 250
					? "<u>&#" + (c < 32 || c > 127 ? 0xB7 : c == 127 ? 0x2588 : c) + ";</u>"
					: "&#" + (c < 32 || c > 127 ? 0xB7 : c == 127 ? 0x2588 : c) + ";") + "</span>";
		document.getElementById("Screen").innerHTML = row.join("<br />");//ram.Chr(0x76D0, 78, 30, (new Date()).getMilliseconds() % 500 > 250 ? ram[0x76CF] + ram[0x76CE] * 78 : -1);//row.join("<br />");
	}
	c = core.watch.iAdjust, i = 1;
		document.getElementById("state").innerHTML = [   "FPS: IPC: IPS: ".replace(/([A-Z]+)/g, function(str, tag) { return ++ i && c -- ? tag : "<u>" + (s = tag) + "</u>"; }),
						("   " + core.trace.flash).substr(-2) + " "
						   + ("     " + core.trace.scale).substr(-6) + " "
							+ ("   " + core.trace.clock).substr(-4)
					].join("\r\n");
	core.watch.nAdjust = i,
	core.watch.sAdjust = s;
	if(core.trace.active)
		core.watch.dirty = 7;
	if(core.watch.dirty > 0)
		-- core.watch.dirty,
		core.disassm();
	document.getElementById("Context").innerText = core.CR(0).Hex(2);
	//core.watch.active = core.watch.active.toUpperCase();
	//core.disassm();
	//document.getElementById("Dumper").innerHTML = this.state.isHalt || !this.state.isRun || this.state.scale == 1 || this.state.isHint ? this.r.ex.Dump() : "";
}

var	x80 =
function(description) {
	var	_CPU_ID_	= "x80-CPU";
	var	preset = {
		instructions	:"pop",
	}
	function AL() {
		console.log("AL " + preset.instructions);
	}
	function step() {
		AL();
		setTimeout(this.step, 1250);
	}
	this.step = step;
}

var	Switches = {
	"ALT+0|Prefix":	function() {cpu.command_set(0); cpu.watch.active = "0";},
	"ALT+1|11+":	function() {cpu.command_set(1); cpu.watch.active = "1";},
	"ALT+2|22+":	function() {cpu.command_set(2); cpu.watch.active = "2";},
	"ALT+3|33+":	function() {cpu.command_set(3); cpu.watch.active = "3";},
	"ALT+4|44+":	function() {cpu.command_set(4); cpu.watch.active = "4";},
	"ALT+5|55+":	function() {cpu.command_set(5); cpu.watch.active = "5";},
	"ALT+6|66+":	function() {cpu.command_set(6); cpu.watch.active = "6";},
	"ALT+7|77+":	function() {cpu.command_set(7); cpu.watch.active = "7";},
	"ALT+8|Prefix":	function() {},
	"ALT+9|Prefix":	function() {},
	"ALT+A|Assm":	function() {document.getElementById("Assm").style.visibility = document.getElementById("Assm").style.visibility == "hidden" ? "visible" : "hidden"},
	"ALT+B|Buffer":	function() {},
	"ALT+C|Context":function() {cpu.watch.context.style.display = cpu.watch.context.style.display == "none" ? "inline" : "none"},
	"ALT+D|Display":function() {document.getElementById("Display").style.display = document.getElementById("Display").style.display == "none" ? "inline" : "none"},
	"ALT+E|Prefix":	function() {},
	"ALT+F|Prefix":	function() {},
};

function main() {
var	i, hClear = setTimeout("window.location.reload()", 15000);
	var	Selector = document.getElementById("Selector");
	var	hFiles = document.getElementsByTagName("pre");
	cpu = new X80(document.getElementById("Schema_x80").innerText);
	cpu.interface({
		instructions	:document.getElementById("Instructions"),
		disassembly	:document.getElementById("Disassembly"),
		registers	:document.getElementById("Registers"),
		address		:document.getElementById("Address"),
		mnemonic	:document.getElementById("Mnemonic"),
		remark		:document.getElementById("Remark"),
		context		:document.getElementById("Context")
	});
	if(i = window.location.href.match(/instructions([1-7])?/)) {
		cpu.command_set(document.getElementById("commands"));
		cpu.command_set(isFinite(i[1]) ? parseInt(i[1]) : 0, true);
		return clearTimeout(hClear);
	}
	for(var file, i = 0; i < hFiles.length; ++ i) {
		file = hFiles[i];
		if(file.id.substr(0, 5) == "FILE:") {
			Selector.add(
				new Option(file.id.substr(5), Files.length),
				null
			);
			cpu.preset.files.push({
				name	:file.id.substr(5),
				text	:file.innerText,
				code	:{
					name	:"",
					begin	:65535,
					end	:0,
					bin	:[]
				}
			});
		}
	}
	var	Triggers = document.getElementById("Triggers");
	//for(var i = 0, btn, spn; i < 16; ++ i) {
	var	i = 0;
	for(var id in Switches) {
		spn = document.createElement("span");
		spn.innerText = " ".Mul(i ++ ? 8 : 6);
		btn = document.createElement("button");
		btn.style.position = "absolute";
		btn.onclick = Switches[id];
		console.log(id);
		id = id.split("|");
		btn.innerText = id[1];
		btn.title = id[0];
		btn.style.zIndex = 0;
		btn.accessKey = id[0].substr(-1);
		Triggers.appendChild(spn);
		Triggers.appendChild(btn);
	}
	Selector.onchange = function(e) {
		document.getElementById("Assm").value = cpu.preset.files[this.selectedIndex].text;
		if(cpu.preset.files[this.selectedIndex].code.length > 0)
			document.getElementById("Action").innerText = "Save It";
		else
			document.getElementById("Action").innerText = "Compile";
	}
	document.getElementById("Action").onclick = function(e) {
		var	i = document.getElementById("Selector").selectedIndex;
		if(cpu.preset.files[i].code.bin.length > 0) {
			this.innerText = "Compiling...";
			cpu.preset.files[i].code = cpu.assembly(cpu.preset.files[i].text, true);
			this.innerText = "Save It";
		} else {
			cpu.preset.files[i].code = cpu.assembly(cpu.preset.files[i].text);
			this.innerText = "Compile";
			cpu.preset.files[i].text = document.getElementById("Assm").value;
			cpu.preset.files[i].bin.length = 0;
		}
	}
	cpu.ram([]);
	cpu.reset(0xFF00);
	cnv = document.getElementById("Display");
	cnv.width = 6 * 80;
	cnv.height = 8 * 30;
	cpu.watch.c2d = cnv.getContext("2d");
	cpu.display(display);
	cpu.command_set(document.getElementById("commands"));
	cpu.disassm();
	document.getElementById("KeyBoard").focus();
	cpu.command_set(4, false);
	setTimeout("cpu.assembly(document.getElementById('BootSection').innerText), cpu.reset(0xFF00)", 1);
	clearTimeout(hClear);
	/////////////////////////////////
	document.getElementById("Address").onkeydown = function(e) {
		var	pointer, i, codes, n = -1;
		var	regs = "ALAHBLBHCLCHDLDHAXBXCXDXSPBPSIDIIPJP".match(/../g);
		var	re = new RegExp("((" + regs.join("|") + ")[1-7]?)" + "|" + "([0-9A-F]+)" + "|" + "(<<|--|>>|\\+\\+)", "g");
		switch(e.keyCode) {
		case	VK.UP:
			cpu.trace.pointer -= 1;
			window.event.returnValue = false;
			cpu.disassm();
			break;
		case	VK.DOWN:
			cpu.trace.pointer += 1;
			window.event.returnValue = false;
			cpu.disassm();
			break;
		case	VK.RETURN:
			pointer = -1;
			codes = this.value.match(re);
			codes.forEach(function(code) {
				if(("<<-->>++".indexOf(code) & 1) == 0)
					switch(code) {
					case "--":
						cpu.ctx[cpu.CR()][0xFFFF & pointer] = (cpu.ctx[cpu.CR()][0xFFFF & pointer] - 1) & 0xFF;
						if(pointer >= 0x100A0 && pointer <= 0x100FF && (pointer & 0x08) == 0 && cpu.ctx[cpu.CR()][0xFFFF & pointer] == 0xFF && n >= 8)
							cpu.ctx[cpu.CR()][0xFFFF & (pointer + 8)] = (cpu.ctx[cpu.CR()][0xFFFF & (pointer + 8)] - 1) & 0xFF;
						pointer ++;
						break;
					case "++":
						cpu.ctx[cpu.CR()][0xFFFF & pointer] = (cpu.ctx[cpu.CR()][0xFFFF & pointer] + 1) & 0xFF;
						if(pointer >= 0x100A0 && pointer <= 0x100FF && (pointer & 0x08) == 0 && cpu.ctx[cpu.CR()][0xFFFF & pointer] == 0x00 && n >= 8)
							cpu.ctx[cpu.CR()][0xFFFF & (pointer + 8)] = (cpu.ctx[cpu.CR()][0xFFFF & (pointer + 8)] + 1) & 0xFF;
						pointer ++;
						break;
					}
				else
				if((n = regs.join("").indexOf(code.substr(0, 2)) >> 1) >= 0)
					pointer = 0x10000 + (n < 8 ? 0xA0 + n * 8 : n < 12 ? 0xA0 + (n - 8) * 16 : 0xE0 + (n - 12) * 2 + (n < 12 ? 0 : 8)) + parseInt("0" + code.charAt(2)), console.log("n:" + n + "/" + pointer.Hex(-5));
				else
				if(code.length == 1)
					pointer = 0x10100 + parseInt(code, 16);
				else
				if(code.length == 4) {
					n = parseInt(code, 16);
					if(pointer < 0)
						cpu.trace.pointer = pointer = parseInt(code, 16);
					else
					if(pointer <= 0xFFFE)
						cpu.ram[pointer ++] = n.lo(),
						cpu.ram[pointer ++] = n.hi();
					else
					if(pointer <= 0x1009F)
						cpu.ctx[cpu.CR()][0xFFFF & pointer ++] = n.lo(),
						cpu.ctx[cpu.CR()][0xFFFF & pointer ++] = n.hi();
					else
					if(pointer <= 0x100FF)
						cpu.ctx[cpu.CR()][0xFFFF & pointer] = n.lo(),
						cpu.ctx[cpu.CR()][0xFFFF & (8 + pointer ++)] = n.hi();
				} else
				if(code.length == 2)
					if(pointer < 0)
						pointer = 0x10000 + parseInt(code, 16);
					else
					if(pointer < 0x10000)
						cpu.ram(pointer ++, parseInt(code, 16));
					else
					if(pointer < 0x10100)
						cpu.ctx[cpu.CR()][0xFFFF & pointer ++] = parseInt(code, 16);
					else
					if(pointer < 0x10108)
						cpu.CR(0x0007 & pointer ++, parseInt(code, 16));
			});
			cpu.disassm();
		}
	};
	document.getElementById("Mnemonic").onkeydown = function(e) {
		switch(e.keyCode) {
		case	VK.UP:
			cpu.trace.pointer -= 1;
			window.event.returnValue = false;
			cpu.watch.active = cpu.watch.active.toLowerCase();
			cpu.disassm();
			break;
		case	VK.DOWN:
			cpu.trace.pointer += 1;
			window.event.returnValue = false;
			cpu.watch.active = cpu.watch.active.toLowerCase();
			cpu.disassm();
			break;
		case	VK.RETURN:
			window.event.returnValue = false;
			cpu.watch.active = cpu.watch.active.toLowerCase();
			cpu.assembly("\tORG\t" + parseInt(document.getElementById("Address").value, 16).Hex(-4) + "\r\n\t" + this.value);
			cpu.disassm();
			break;
		default:
			cpu.watch.active = cpu.watch.active.toUpperCase();
		}
	};
	document.getElementById("Remark").onkeydown = function(e) {
		switch(e.keyCode) {
		case	VK.TAB:
			window.event.returnValue = false;
			document.getElementById("Address").focus();
			break;
		}
	}
	document.getElementById("KeyBoard").onkeydown = function(e) {
		window.event.returnValue = false;
		switch(e.keyCode) {
		case	VK.TAB:		this.value += "`I"; break;
		case	VK.ESC:		this.value += "`["; break;
		case	VK.BACK_SPACE:	this.value += "`{"; break;
		case	VK.LEFT:	this.value += "`H"; break;
		case	VK.RETURN:	this.value += "`M"; break;
		default:
			window.event.returnValue = true;
		}
	}
	document.getElementById("KeyBoard").onkeyup = function(e) {
		window.event.returnValue = false;
		switch(e.keyCode) {
		case	VK.TAB:
		case	VK.ESC:
		case	VK.BACK_SPACE:
		case	VK.LEFT:
		case	VK.RETURN:	break;
		default:
			window.event.returnValue = true;
		}
	}
	document.body.onkeydown = function(e) {
		switch(e.keyCode) {
/*		case	VK.ESC:		// ESC
			cpu.iox[0xFD].data(0x1B); break;
			cpu.preset.command_cycles = -Math.abs(cpu.preset.command_cycles), cpu.do_tick(true); break;
		case	VK.LEFT:	// <--
			cpu.iox[0xFD].data(0x08); break;
		case	VK.UP:		// //\
			cpu.iox[0xFD].data(0x19); break;
		case	VK.RIGHT:	// -->
			cpu.iox[0xFD].data(0x18); break;
		case	VK.DOWN:	// \//
			cpu.iox[0xFD].data(0x1A); break;
		case	VK.BACK_SPACE:	// \//
			cpu.iox[0xFD].data(0x7F); break;
*/		////////////////////////////////////
		case	VK.BREAK:	// Break-point
			cpu.trace.halt[Number().hl(cpu.CTX(0xF8), cpu.CTX(0xF0))] ^= true;
			if(e.shiftKey)
				cpu.trace.halt[(Number().hl(cpu.CTX(0xF8), cpu.CTX(0xF0)) + 1) & 0xFFFF] = false;
			cpu.disassm();
			break;
		case	VK.F1:		// Step
			if(e.ctrlKey) {	// Start cycle
				/*var	ip = cpu.r.ip;
				cpu.do_tick(true);
				cpu.r.qp = ip;
				cpu.trace.active = false;*/
			} else
			if(e.shiftKey)
				cpu.step(),
				cpu.trace.active = true;
			else
			if(e.altKey)
				cpu.state.isHint ^= true;
			else
				cpu.trace.step = true;//cpu.do_tick(true);
//			cpu.disassm();
			window.event.returnValue = false;
			break;
		case	VK.F7:
			cpu.watch.iAdjust = (cpu.watch.iAdjust + 1) % cpu.watch.nAdjust;
			window.event.returnValue = false;
			break;
		case	VK.F6:		// IP --
			switch(cpu.watch.sAdjust) {
			case	"FPS":
				cpu.trace.flash -= cpu.trace.flash > 1 ? 1 : 0;
				break;
			case	"IPS":
				cpu.trace.clock >>= cpu.trace.clock & 1 ? 0 : 1;
				break;
			case	"IPC":
				cpu.trace.scale >>= cpu.trace.scale & 1 ? 0 : 1;
				break;
			default:
				var	txt = document.getElementById("Logger").value.split(/\r?\n/).pop().toUpperCase().split(/[\s\t]+/);
				cpu.do_regs(txt[0], -1);
				cpu.trace.active = true;
			}
			cpu.disassm();
			break;
		case	VK.F8:		// IP ++
			switch(cpu.watch.sAdjust) {
			case	"FPS":
				cpu.trace.flash += cpu.trace.flash < 50 ? 1 : 0;
				break;
			case	"IPS":
				cpu.trace.clock <<= cpu.trace.clock < 1000 ? 1 : 0;
				break;
			case	"IPC":
				cpu.trace.scale <<= cpu.trace.scale < 500000 ? 1 : 0;
				break;
			default:
				var	txt = document.getElementById("Assm").value.split(/\r?\n/).pop().toUpperCase().split(/[\s\t]+/);
				cpu.do_regs(txt[0], +1);
				cpu.trace.active = true;
			}
			cpu.disassm();
			break;
		case	VK.F5:		// Assembly/Reset
			window.event.returnValue = false;
			if(e.ctrlKey)	// Reset
				cpu.JP(0, 0xF800),
				cpu.JP(1, 0xE000),
				cpu.reset(0xFF00);
			else		// Assembly
				cpu.trace.active = true,
				cpu.assembly(document.getElementById("Assm").value);
			cpu.disassm();
			break;
		case	VK.F4:		// Start/Break emulation
			if(e.shiftKey)
				cpu.trace.active = false;
			else
				cpu.trace.active = !cpu.trace.active;
			cpu.disassm();
			break;
		case	VK.F3:
			if(e.ctrlKey)
				cpu.stack(cpu.r.ip);
			else
			if(e.shiftKey)
				cpu.r.ip = cpu.stack();
			cpu.disassm();
			window.event.returnValue = false;
			break;
		case	VK.RETURN:
			if(e.shiftKey);
			break;
		default:
			if(e.ctrlKey && e.keyCode > 48 && e.keyCode <= 56)
				cpu.CR(0, e.keyCode & 7);
		break;if(e.altKey && e.keyCode >= 48 && e.keyCode <= 55)
				cpu.command_set(e.keyCode & 7, false);
				//cpu.iox[0xFD].data(e.keyCode);
		}
	}
	document.body.onkeyup = function(e){
		switch(e.keyCode) {
		case	VK.F1:		// Help
		case	VK.F3:		// Push/Pop
		case	VK.F5:		// Assembly
			window.event.returnValue = false;
			break;
		default:
			//cpu.iox[0xFD].data(0xFF); break;
		}
	}
	document.getElementById("Assm").onkeydown = function(e) {
		if(e.keyCode == 13) {
			if(e.ctrlKey) {
				var	txt = document.getElementById("Assm").value.split(/\r?\n/).pop().toUpperCase().split(/[\s\t]+/);
				cpu.do_regs(txt[0], txt[1]);
				cpu.disassm();
			} else
			if(e.shiftKey) {
				var	keybrd = document.getElementById("Assm"),
					start = keybrd.selectionStart,
					ascii;
				if(keybrd.value.length > start) {
					//ascii = keybrd.value.charAt(start).toUpperCase();
					//cpu.iox[0xFD].data(
					document.getElementById("KeyBoard").value = keybrd.value.substr(start).replace(/[Ёё]/igm, "Е").replace(/[Ъъ]/igm, "'").replace(/(`[A-Z@\[\\\]\^_\x01-\x1F]|.)/gm,
						function(str, ascii) {
					//		alert(str + '...........'+ascii);
							ascii = ascii.toUpperCase();
							if(ascii.length == 2)
								return "`" + ascii.charAt(1);
							var	koi7ru = "ЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ",
								data = koi7ru.indexOf(ascii);
							if(data < 0)
								return ascii.charCodeAt(0) < 0x7F && ascii.charCodeAt(0) >= 32 ? ascii.toUpperCase() : ascii.charCodeAt(0) < 32 ? "`" + String.fromCharCode(ascii.charCodeAt(0) + 64) : "";
							return	String.fromCharCode(96 + data);
						}
					);
				}/*
				alert("1$"+cpu.iox[0xFD].text);
				alert("1#"+cpu.iox[0xFD].data());
				alert("1@"+cpu.port(0xFD));
				alert("2$"+cpu.iox[0xFD].text);
				alert("2#"+cpu.iox[0xFD].data());
				alert("2@"+cpu.port(0xFD));
				alert("3$"+cpu.iox[0xFD].text);
				alert("3#"+cpu.iox[0xFD].data());
				alert("3@"+cpu.port(0xFD));*/
				window.event.returnValue = false;
			}
		} else
		if(e.keyCode == 9) {
			var	start = this.selectionStart, end = this.selectionEnd;
			this.value = this.value.substr(0, start) + "\t" + this.value.substr(end),
			this.selectionStart = start + 1,
			this.selectionEnd = start + 1,
			window.event.returnValue = false;
		}
	}
	document.getElementById("Assm").onkeyup = function(e) {
		if(e.keyCode == 9) {
			window.event.returnValue = false;
		}
	}
	return;
//return;
	/*var	part =	"F800	JMP	0xF701"
			.split(/\s|\t/),
		arg_nnIB,
		ip = parseInt(part[0], 16),
		ipx = ip*0,
		instr = part[1],
		regs = part[2],
		args = [],
		ins = {	"$+IB": {},
			"$+1IB": {},
			"$+2IB": {},
			"$+3IB": {},
			"$+4IB": {},
			"$+5IB": {},
			"$+6IB": {},
			"$+7IB": {},	};
					arg_nnIB = regs.replace(/(0x[0-9A-F]+)|([0-9]+)/gi, function(str, data) {	// nnIB
						var	bin0 = parseInt(data);
						var	tag0 = regs.replace(/\+(0x[0-9A-F]+|[0-9]+)/, "+IB");
						var	bin1 = parseInt(data);
						var	tag1 = bin1.hi().Hex(2) + "IB";
						var	bin2 = parseInt(data) - (ip + 2) - ipx;
				//			bin2 -= (bin2 & 32768) * 2;
						var	tag2 = "$+IB";
						var	bin3 = parseInt(data) - (ip + 3) - ipx;
						//bin3 += (bin3 & 32768) * 2;
						//bin3 += (bin3 < -128 ? +(bin3 & 0x80) * 2 : bin3 >= 128 ? +(bin3 & 0x80) * 2 : 0);
						var	bin3a = bin3 + (bin3 < -128 ? +(bin3 & 0x80) * 2 : bin3 >= 128 ? +(bin3 & 0x80) * 2 : 0);
						var	tag3 = "$+" + ((bin3a >> 8) & 7) + "IB";
						console.log([ip.Hex(4), "bin0", instr, str, bin0.Hex(4), bin0, "?" + ins + "?" + tag0].join(" "));
						console.log([ip.Hex(4), "bin1", instr, str, bin1.Hex(4), bin1, "?" + ins + "?" + tag1].join(" "));
						console.log([ip.Hex(4), "bin2", instr, str, bin2.Hex(4), bin2, "?" + ins + "?" + tag2].join(" "));
						console.log([ip.Hex(4), "bin3", instr, str, bin3.Hex(4), bin3, "?" + ins + "?" + tag3].join(" "));
						console.log([ip.Hex(4), "bin3a", instr, str, bin3a.Hex(4), bin3a, "?" + ins + "?" + tag3].join(" "));
						if(ins) {
							if(tag0 in ins) {
								console.log("0");
								return	args.push(bin0) ? "IB" : "IB";
							}
							if(tag1 in ins) {
								console.log("1");
								return	args.push(bin1) ? tag1 : tag1;
							}
							if(bin2 >= -128 && bin2 < 128 && (tag2 in ins)) {
								console.log("2");
								return	args.push(bin2.lo()) ? tag2 : tag2;
							}
							if(((bin3 >= -1024 && bin3 < -128) || (bin3 >= 128 && bin3 <= 895)) && (tag3 in ins))	{//console.log("bin3="+bin3+"");
								console.log("3");
								return	args.push(bin3.lo()) ? tag3 : tag3;					//}//else console.log("bin3="+bin3+" tag3=" + tag3 + "/" + (tag3 in ins));
							}
							if("IB" in ins) {
								console.log("4");
								return	args.push(bin1) ? "IB" : "IB";
							}
							if(part[4] && (regs.split(",")[0] + ",IB") in ins) {
								console.log("5");
								return	(code = ins[part[3] + ",IB"]) && args.push(bin1) ? "" : "";
							}
							if("" in ins)
								return	"";
						}
						args.push(bin1);
						//console.log([ip.Hex(4), "nnIB//", instr, str, bin1.Hex(4), bin1].join(" "));
						return "";
					});
	console.log(arg_nnIB);
	console.log(args[0].Hex(4) + "=" + (args[0] - (args[0] & 32768) * 2));
	return;*/
	var	url = window.location.href, match = 0, i;
	Source = document.getElementById("Listing").innerText;
	cpu.preset.command_speed = +((match = url.match(/speed=([^&]+)/)) ? match[1] : .1*0+500);
	cpu.preset.command_cycles = +((match = url.match(/cycle=([^&]+)/)) ? match[1] : 1);
	cpu.preset.command_reset = +((match = url.match(/reset=([^&]+)/)) ? match[1] : 1);
	cpu.init(document.getElementById("Schema").innerText);
	if(url.match(/instructions/)) {
		var	body = document.createElement("body");
		cpu.preset.command_table = document.createElement("pre");
		var	span = document.createElement("span");
		cpu.preset.command_table.id = "commands";
		span.id = "expression";
		body.appendChild(cpu.preset.command_table);
		body.appendChild(span);
		body.style.backgroundColor = "steelblue";
		document.body = body;
		cpu.command_set(0, true);
		return;
	}
	for(i = 0; i < 264; ++ i)
		cpu.preset.regs.asx[i] = 0,
		cpu.preset.regs.atx[i] = 0;
	for(i = 0x0000; i <= 0xFFFF; ++ i)
		cpu.halt[i] = false;
	for(i = 0x0000; i <= 0x00FF; ++ i) {
		if(!isFinite(cpu.iox[i]) && !cpu.iox[i])
			cpu.iox[i] = 0x80;
	}
	//alert(cpu.iox[0xD0].data().Hex(2));
	for(i = 0x76CE; i <= 0x7FF3; ++ i)
		cpu.ram[i] = Math.random() * 256 & 0;
	cpu.iox[0xF1].data(document.getElementById("Files").innerText);
	cpu.do_reset();
	i = 0;
	document.getElementById("Listing").innerText.replace(/\s*;.*/gm, "").replace(/([0-9A-F]{4})(?:\:)|([0-9A-F]{2})(?:\s)/gm, function(str, p1, p2) {
		if(p1)
			i = parseInt(p1, 16);
		if(p2)
			cpu.ram[i ++] = parseInt(p2, 16);
		return "_";
	});
	cpu.preset.command_table = document.getElementById("commands");
	cpu.command_set(Math.floor((new Date()).getSeconds() / 3) % 11 * 0);
	cpu.display();
	cpu.disassm();
	////////////////////////////////////////
	setTimeout(function() {
//			cpu.assembly(Source);
			document.getElementById("Logger").value = Source;//\
"	ORG	0xF780\
\rgoe:	NOP\
\r	ORG	0xF800\
\rgo:	NOP\
\r	JC	$-1\
\r	NOP\
\r	JMP	goal\
\r	NOP\
\r	DW	0xB977\
\r	DB	0x01\
\r	NOP\
\r	JS	goe\
\r	NOP\
\r	ORG	0xF903\
\rgoal:	NOP\
\r!IP	0x100";
			cpu.assembly(document.getElementById("Logger").value);
			cpu.disassm();
			document.getElementById("Logger").focus();
			//cpu.state.hTimer = setInterval("cpu.do_tick()", 1500);
			//AudioInit();
		}, 1);
	//cpu.assembly("	ORG 0xF800\r\nStart:\r\n	INC BX_DX\r\n	POP	AX_CX\r\n");
	document.body.onkeypress = function(e) {
		cpu.iox[0xFD].data(e.keyCode);//e.charCode;
			document.title+=" _"+e.keyCode.Hex(4);
//			window.event.returnValue = false;
	}
	document.body.onkeyup = function(e){
		switch(e.keyCode) {
		case	VK.F1:		// Help
		case	VK.F3:		// Push/Pop
		case	VK.F5:		// Assembly
			window.event.returnValue = false;
			break;
		default:
			//cpu.iox[0xFD].data(0xFF); break;
		}
		document.title+=" ^"+e.keyCode.Hex(4);
	}
}
</script>
</head>
<body onload='main()'>
<var id=Schema_x80>
<!--
A:ALU
B:Branch
C:Control
D:Dubbed register pair
E:Stack
F:Flip-flop move
		 _ ?00: #Y == #X 
                /_ ?01: #Z <  #X
 +--(#J == 0)--<__ ?10: #Z  > #X
 |              \_ 1??: #Y >  #X
 |
 |               _ ??0: #IX < 10
 |              /_ ?0?: #X < 6 && 
 +--(#J == 1)--<__ 0??: #X < 7
 |               
 |  +---------=> #Z
 |  | +-------=> #J
 |  | | +-----=> #Y
 |  | | | +---=> #I
 |  | | | | +-=> #X
 |  | | | | |
/|\/|\|/|\|/|\-->
XXX00000000000C	HLT			:IS_BOOT ? IS_WAIT ? CR(0, ACC()) : FH(8) : (CR(CR(0) & 0xF0), FH(0xB), FL(0x5))				// Halting
XXX00011111110C	NOP			:$IB==$IB													// No operation
0000000XXX0XXX_	PREFIX	R#X/P#X		:0														// Prefix for R#X!/P#X!
X1000011101XXXE	PUSH+	U#X		:HEAP(U#X())													// Push pointer into stack
X1000011111XXXE	POP+	U#X		:U#X(HEAP())													// Pop pointer from stack
XXXXXX11111110C	NOP	#Z		:#Z														// Hollow operation through #Z ticks
XXX10010101XXXA	ALU#X	IB		:$1=ALU#X(DROP(FH()),$IB),ACC($1),FL($1.hi())									// ALU#X! with retained and immediate
XXXXXX10101XXXA	ALU#X	Z#Z,IB		:$1=ALU#X(Z#Z(),$IB),Z#Z($1),FL($1.hi())									// ALU#X! with Z#Z! and byte
XXX1000XXX1XXXA	ALU#X	Z#Y		:$1=ALU#X(DROP(#Y),REG(#Y)),REG(#Y,$1),FL($1.hi())								// ALU#X! with Z#Y! and retained
XXXXXX0XXX1XXXA	ALU#X	Z#Z,R#Y		:$1=ALU#X(Z#Z(),R#Y()),Z#Z($1),FL($1.hi())									// ALU#X! with Z#Z! and R#Y!
000XXX0XXX0XXXC	HLT	#Z		:IS_BOOT && IS_WAIT ? FH()==(#Z+8) ? ACC(PORT(ACC())) : FH()>=8 ? PORT(ACC(),REG(#Z)) : ACC(CR(#Z)) : FH(#Z+8)		// Hold #Z index number
X1000011001XXXD	INC+	Q#X		:Q#X(Q#X()+1)													// Increment Q#X!
X1000011011XXXD	DEC+	Q#X		:Q#X(Q#X()-1)													// Decrement Q#X!
XXX00011001111A	CMC			:FL(FL() ^ 2)													// Complement carry flag
XXXXXX11001110D	ADC	BX,P#Z		:$1=BX()+P#Z()+(_CF?1:0),$2=($1>>15)&2,FL((FL()& 0xD)|$2), BX($1)						// Addition register pair with carry
X10XXX11001XXXD	ADD	Q#X,P#Z		:$1=Q#X()+P#Z()+(_CF?0:0),$2=($1>>15)&2,FL((FL()& 0xD)|$2), Q#X($1)						// Addition register pair
XXXXXX11011110D	SBB	BX,P#Z		:$1=BX()-P#Z()-(_CF?1:0),$2=($1>>15)&2,FL((FL()& 0xD)|$2), BX($1)						// Subtraction register pair with borrow
X10XXX11011XXXD	SUB	Q#X,P#Z		:$1=Q#X()-P#Z()-(_CF?0:0),$2=($1>>15)&2,FL((FL()& 0xD)|$2), Q#X($1)						// Subtraction register pair
XXX00011001010A	XCHG			:$1=ACC(); for($2=0,$0=0;$0<8;++$0,$1>>=1) $2=($2<<1)+($1&1); ACC($2)>0						// Exchange retained bits by mirror
XXXXXX11001010A	XCHG	P#Z		:$1=DST(),DST(P#Z()),P#Z($1)											// Exchange P#Z! with retained pair
XXXXXX11001111A	XCHG	R#Z		:$1=ACC(),ACC(R#Z()),R#Z($1)											// Exchange R#Z! with retained register
XXX100110X1XXXA	ALU#W			:$1=ACC(ALU#W(ACC())),FL($1.hi())										// ALU#W! with retained
XXXXXX110X1XXXA	ALU#W	Z#Z		:$1=Z#Z(ALU#W(Z#Z())),FL($1.hi())										// ALU#W! with Z#Z!
01110000000XXXD	PUSH+	T#X+[T#Y]	:HEAP(T#X()+DW(T#Y()))												// Correct effective address in stack
0111000XXX0XXXD	PUSH+	T#X+T#Y		:HEAP(T#X()+T#Y())												// Push effective address into stack
1111000XXX0000D	PUSH+	[T#X]-T#Y	:HEAP(HEAP()-T#Y())												// Correct effective address in stack
1111000XXX0XXXD	PUSH+	T#X-T#Y		:HEAP(T#X()-T#Y())												// Push effective address into stack
XXXXXX00000000C	HLT	R#Z		:/*IS_BOOT && */IS_WAIT ? FH() == #Z ? ACC(CTX(ACC())) : $IR ? CTX(ACC(),R#Z()) : CR(FH(),R#Z()) : FH(#Z)		// Hold R#Z!/P#Z! as retained
XXX0000XXX0XXXF	MOV	R#X,R#Y		:R#X(R#Y())													// Move R#Y! data into R#X!
XXX00010100XXXF	MOV	R#X,IB		:R#X($IB)													// Move immediate data into R#X!
XXX00010110000B	JCND#X	$+IB		:CND#X?IP(IP()+$IV):0												// Relative branching if CND#X!
XXX00010110001E	BIAS	$+IB		:HEAP($IP+$IV)													// Push instruction based relative address
XXX00010110XXXB	CCND#X	$+IB		:CND#X?HEAP(IP())+IP(IP()+$IV):0										// Relative call if CND#X!
XXX00011000XXXA	INC+	R#X		:$1=ADD(R#X(),1),R#X($1),FL($1.hi())										// Increment R#X!
XXX00011010XXXA	DEC+	R#X		:$1=SUB(R#X(),1),R#X($1),FL($1.hi())										// Decrement R#X!
X00XXX1111XXXXB	INT	#T		:HEAP($IP)+IP(JP(#T<10?0:1))>0											// Programm interruption indexed by #T
XXX10011101110F	XCHG	[SP]		:$1=DST(),DST(DW($2=SP())), DW($2, $1)										// Exchange retained pair with stack heap
XXXXXX11101110F	XCHG	P#Z,[SP]	:$1=P#Z(),P#Z(DW(SP())), DW(SP(), $1)										// Exchange pair P#Z with stack heap
001XXX0XXX0XXXF	XCHG	P#Z,P#Y		:$1=P#Z(),P#Z(P#Y()),P#Y($1)											// Exchange P#Z! and P#Y!
010XXX0XXX0XXXF	XCHG	R#Z,R#Y		:$1=R#Z(),R#Z(R#Y()),R#Y($1)											// Exchange R#Z! and R#Y!
011XXX0XXX0XXXD	LEA	P#Z,T#X+T#Y	:P#Z(T#X()+T#Y())												// Load T#X!+T#Y! effective address into P#Z
111XXX0XXX0XXXD	LEA	P#Z,T#X-T#Y	:P#Z(T#X()-T#Y())												// Load T#X!-T#Y! effective address into P#Z
XXXXXX10100000E	POP+	[P#Z+IB]	:DW(P#Z()+$IV,HEAP())												// Pop data into memory indexed by P#Z
XXXXXX10100XXXF	MOV	R#X,[P#Z+IB]	:trace.is_port=IP_BP; trace.is_context=IP_SP; R#X(DB(P#Z()+$IV))						// Move memory data by P#Z pointer into R#X
XXXXXX10110000E	PUSH+	[P#Z+IB]	:HEAP(DW(P#Z()+$IV))												// Push data from memory indexed by P#Z
XXXXXX10110XXXF	MOV	[P#Z+IB],R#X	:trace.is_port=IP_BP; trace.is_context=IP_SP; DB(P#Z()+$IV,R#X())						// Move R#X register data into memory by P#Z
XXX10011101111E	PUSH			:HEAP(DST())													// Push retained pair
XXXXXX11101111E	PUSH+	S#Z		:HEAP(S#Z())													// Push service S#Z register pair to stack
XXX10011111111E	POP			:DST(HEAP())													// Pop retained pair
XXXXXX11111111E	POP+	S#Z		:S#Z(HEAP())													// Pop service S#Z register pair from stack
XXXXXX11101010E	PUSH+	R#Z		:DUP(#Z)													// Dup R#Z register history
XXXXXX11101011C	SKIP	[R#Z]		:FH(R#Z()|8),FL((FL() & 0x02) | 0x05)										// Exclude next operations by R#Z bits
XXXXXX11101100C	SKIP	R#Z		:FH(#Z), FL((FL() & 0x02) | 0x05)										// Exclude next operations by R#Z counter
XXXXXX11101101C	SKIP	#Z		:FH(#Z | 8), FL((FL() & 0x02) | 0x05)										// Exclude next operations by #Z times
XXXXXX11111010E	POP+	R#Z		:DROP(#Z)													// Drop R#Z register history
XXXXXX11111011C	LOOP	[R#Z]		:FH(R#Z()|8),FL((FL() & 0x02) | 0x09)										// Forcing next operation by R#Z bits
XXXXXX11111100C	LOOP	R#Z		:FH(#Z), FL((FL() & 0x02) | 0x09)										// Forcing next operation by R#Z counter
XXXXXX11111101C	LOOP	#Z		:FH(#Z | 8), FL((FL() & 0x02) | 0x09)										// Forcing next operation by #Z times
XXXXXX100XXXXXE	PUSH+	#VIB		:HEAP(0x#V00 + $IB)												// Push immediate data into stack
0XX10010111XXXX	---	IB		:return 0													// Reserved extended code
XXX10010111010E	LEA	+IB		:DST(DST()+$IB)													// Load retained effective address
X1010010111XXXF	MOV	[U#X],IB	:DB(U#X(),$IB)													// Load immediate data into memory by U#X
XXXXXX10111000B	JMP	$+#UIB		:$IW==-2?(FL((FL() & 0x02) | 0x0D),trace.expression=""):IP(IP()+$IW)						// Unonditional relative branching
XXXXXX10111001B	CALL	$+#UIB		:$IW==-2?0:HEAP(IP(IP()+$IW))											// Unconditional relative call
XXXXXX10111XXXB	JCND#X	$+#UIB		:CND#X?IP(IP()+$IW):0												// Branching if CND#X!
XXXXXXXXXXXXXXX	---			:return 0													// Reserved code

// Helpers
ALU08	ROL	ROL	Roll Overflow Left
ALU09	RCL	RCL	Roll Cyclic Left
ALU0A	XCHG
ALU0F	NEG	0
ALU18	ROR	ROR	Roll Overflow Right
ALU19	RCR	RCR	Roll Cyclic Right
ALU1A	RAR	RAR	Roll Arithmetic Right
ALU1F	NOT	NOT	Bitwise NOT
ALU0	ADC	ADC	Addition with carry
ALU1	SBB	SBB	Subtract with borrow
ALU2	ADD	ADD	Addition
ALU3	SUB	SUB	Subtract
ALU4	AND	AND	Bitwise AND/conjunct
ALU5	OR	OR	Bitwise OR/disjunct
ALU6	XOR	XOR	Bitwise eXclusive OR
ALU7	CMP	CMP	Comparation

// Register descriptions
// Pointers
P0	IP	IP	IP
P1	BP	BP	BP
P2	SI	SI	SI
P3	DI	DI	DI
P4	SP	SP	SP
P5	BX	BX	DX
P6	CX	CX	CX
P7	DX	DX	DX

// Quad
Q3	BX	BX	BX
Q4	CX	CX	CX
Q5	DX	DX	DX
Q6	SP	SP	SP

// Regular
R0	[BX]	_BX_	[BX]
R1	BH	BH	BH
R2	CH	CH	CH
R3	DH	DH	DH
R4	AL	AL	AL
R5	BL	BL	BL
R6	CL	CL	CL
R7	DL	DL	DL

// Special
S0	IP	IP	IP
S1	BP	BP	BP
S2	SI	SI	SI
S3	DI	DI	DI
S4	[SP]	_SP_	[SP]
S5	EX	Extend	Ex
S6	SX	SX	Sx
S7	TX	Timers	Tx

// Tabular
T0	SP	SP	SP
T1	BP	BP	BP
T2	SI	SI	SI
T3	DI	DI	DI
T4	AL	_AL_	AL
T5	BX	BX	BX
T6	CX	CX	CX
T7	DX	DX	DX

// Unical
U2	AX	AX	AX
U3	BX	BX	BX
U4	CX	CX	CX
U5	DX	DX	DX

Z0	AL	AL	AL
Z1	BH	BH	BH
Z2	CH	CH	CH
Z3	DH	DH	DH
Z4	AL	AL	AL
Z5	BL	BL	BL
Z6	CL	CL	CL
Z7	DL	DL	DL

_ZF	ZF	!!(FL() & 1)
_CF	CF	!!(FL() & 2)
_PF	PF	!!(FL() & 4)
_SF	SF	!!(FL() & 8)

// Conditional
CND0	PE	!!(FL() & 4)	Parity is Even
CND1	PO	!(FL() & 4)	Parity is Odd
CND2	S	!!(FL() & 8)	result is Signed
CND3	NS	!(FL() & 8)	result is Not Signed
CND4	C	!!(FL() & 2)	result with Carry
CND5	NC	!(FL() & 2)	result with No Carry
CND6	Z	!!(FL() & 1)	result is Equal
CND7	NZ	!(FL() & 1)	result is Not Equal

IS_BOOT	IS_BOOT	(CR() == 0)
IS_WAIT	IS_WAIT	($IE == 3)
IP_BP	IP_BP	(BP().hi()==IP().hi() && ((#Z==1)||(#Z==4)))
IP_SP	IP_SP	(SP().hi()==IP().hi() && (#Z==4))

// Aliases
WAIT!0		@B8 FE F0		Express Function #0
WAIT!1		@B8 FE F1		Express Function #1
WAIT!2		@B8 FE F2		Express Function #2
WAIT!3		@B8 FE F3		Express Function #3
WAIT!4		@B8 FE F4		Express Function #4
WAIT!5		@B8 FE F5		Express Function #5
WAIT!6		@B8 FE F6		Express Function #6
WAIT!7		@B8 FE F7		Express Function #7
WAIT!8		@B8 FE F8		Express Function #8
WAIT!9		@B8 FE F9		Express Function #9
CALL![SP]	@EE			Call subroutine
WAIT!		@B8 FE			Waitable mode
HLT 0		@00
HLT BP		@11 00
HLT SI		@22 00
HLT DI		@33 00
HLT [SP]	@44 00
HLT BX		@55 00
HLT CX		@66 00
HLT DX		@77 00
CLC!		@BD 01 CF		Clear CARRY FLAG
STC!		@BC 01 CF		Store CARRY FLAG
RPE!		@B0 FF			Return by EVEN PARITY
RPO!		@B1 FF			Return by ODD PARITY
RS!		@BA FF			Return by Positive
RNS!		@BB FF			Return by Negative
RC!		@BC FF			Return by CARRY
RNC!		@BD FF			Return by not CARRY
RZ!		@BE FF			Return by ZERO
RNZ!		@BF FF			Return by not ZERO
RET!		@FF			Return from subroutine
MOV!BX,CX	@21 65			Load %Y register pair to %X
MOV!BX,DX	@31 75			Load %Y register pair to %X
MOV!CX,BX	@12 56			Load %Y register pair to %X
MOV!CX,DX	@31 76			Load %Y register pair to %X
MOV!DX,BX	@13 57			Load %Y register pair to %X
MOV!DX,CX	@23 67			Load %Y register pair to %X
MOV!BP,SI	@22 EF 11 FF		Load %Y register pair to %X
MOV!BP,DI	@33 EF 11 FF		Load %Y register pair to %X
MOV!BP,BX	@EB 11 FF		Load %Y register pair to %X
MOV!BP,CX	@EC 11 FF		Load %Y register pair to %X
MOV!BP,DX	@ED 11 FF		Load %Y register pair to %X
MOV!SI,BP	@11 EF 22 FF		Load %Y register pair to %X
MOV!SI,DI	@33 EF 22 FF		Load %Y register pair to %X
MOV!SI,BX	@EB 22 FF		Load %Y register pair to %X
MOV!SI,CX	@EC 22 FF		Load %Y register pair to %X
MOV!SI,DX	@ED 22 FF		Load %Y register pair to %X
MOV!DI,BP	@11 EF 33 FF		Load %Y register pair to %X
MOV!DI,SI	@22 EF 33 FF		Load %Y register pair to %X
MOV!DI,BX	@EB 33 FF		Load %Y register pair to %X
MOV!DI,CX	@EC 33 FF		Load %Y register pair to %X
MOV!DI,DX	@ED 33 FF		Load %Y register pair to %X
MOV!BX,BP	@11 EF FB		Load %Y register pair to %X
MOV!BX,SI	@22 EF FB		Load %Y register pair to %X
MOV!BX,DI	@33 EF FB		Load %Y register pair to %X
MOV!CX,BP	@11 EF FC		Load %Y register pair to %X
MOV!CX,SI	@22 EF FC		Load %Y register pair to %X
MOV!CX,DI	@33 EF FC		Load %Y register pair to %X
MOV!DX,BP	@11 EF FD		Load %Y register pair to %X
MOV!DX,SI	@22 EF FD		Load %Y register pair to %X
MOV!DX,DI	@33 EF FD		Load %Y register pair to %X
MOV [0],BH	@00 B8 FE 11 00		Set control register #%X by %Y
MOV [0],CH	@00 B8 FE 22 00		Set control register #%X by %Y
MOV [0],DH	@00 B8 FE 33 00		Set control register #%X by %Y
MOV [0],AL	@00 B8 FE 44 00		Set control register #%X by %Y
MOV [0],BL	@00 B8 FE 55 00		Set control register #%X by %Y
MOV [0],CL	@00 B8 FE 66 00		Set control register #%X by %Y
MOV [0],DL	@00 B8 FE 77 00		Set control register #%X by %Y
MOV [1],BH	@11 11 B8 FE 11 00	Set control register #%X by %Y
MOV [1],CH	@11 11 B8 FE 22 00	Set control register #%X by %Y
MOV [1],DH	@11 11 B8 FE 33 00	Set control register #%X by %Y
MOV [1],AL	@11 11 B8 FE 44 00	Set control register #%X by %Y
MOV [1],BL	@11 11 B8 FE 55 00	Set control register #%X by %Y
MOV [1],CL	@11 11 B8 FE 66 00	Set control register #%X by %Y
MOV [1],DL	@11 11 B8 FE 77 00	Set control register #%X by %Y
MOV [2],BH	@22 22 B8 FE 11 00	Set control register #%X by %Y
MOV [2],CH	@22 22 B8 FE 22 00	Set control register #%X by %Y
MOV [2],DH	@22 22 B8 FE 33 00	Set control register #%X by %Y
MOV [2],AL	@22 22 B8 FE 44 00	Set control register #%X by %Y
MOV [2],BL	@22 22 B8 FE 55 00	Set control register #%X by %Y
MOV [2],CL	@22 22 B8 FE 66 00	Set control register #%X by %Y
MOV [2],DL	@22 22 B8 FE 77 00	Set control register #%X by %Y
MOV [3],BH	@33 33 B8 FE 11 00	Set control register #%X by %Y
MOV [3],CH	@33 33 B8 FE 22 00	Set control register #%X by %Y
MOV [3],DH	@33 33 B8 FE 33 00	Set control register #%X by %Y
MOV [3],AL	@33 33 B8 FE 44 00	Set control register #%X by %Y
MOV [3],BL	@33 33 B8 FE 55 00	Set control register #%X by %Y
MOV [3],CL	@33 33 B8 FE 66 00	Set control register #%X by %Y
MOV [3],DL	@33 33 B8 FE 77 00	Set control register #%X by %Y
MOV [4],BH	@44 44 B8 FE 11 00	Set control register #%X by %Y
MOV [4],CH	@44 44 B8 FE 22 00	Set control register #%X by %Y
MOV [4],DH	@44 44 B8 FE 33 00	Set control register #%X by %Y
MOV [4],AL	@44 44 B8 FE 44 00	Set control register #%X by %Y
MOV [4],BL	@44 44 B8 FE 55 00	Set control register #%X by %Y
MOV [4],CL	@44 44 B8 FE 66 00	Set control register #%X by %Y
MOV [4],DL	@44 44 B8 FE 77 00	Set control register #%X by %Y
MOV [5],BH	@55 55 B8 FE 11 00	Set control register #%X by %Y
MOV [5],CH	@55 55 B8 FE 22 00	Set control register #%X by %Y
MOV [5],DH	@55 55 B8 FE 33 00	Set control register #%X by %Y
MOV [5],AL	@55 55 B8 FE 44 00	Set control register #%X by %Y
MOV [5],BL	@55 55 B8 FE 55 00	Set control register #%X by %Y
MOV [5],CL	@55 55 B8 FE 66 00	Set control register #%X by %Y
MOV [5],DL	@55 55 B8 FE 77 00	Set control register #%X by %Y
MOV [6],BH	@66 66 B8 FE 11 00	Set control register #%X by %Y
MOV [6],CH	@66 66 B8 FE 22 00	Set control register #%X by %Y
MOV [6],DH	@66 66 B8 FE 33 00	Set control register #%X by %Y
MOV [6],AL	@66 66 B8 FE 44 00	Set control register #%X by %Y
MOV [6],BL	@66 66 B8 FE 55 00	Set control register #%X by %Y
MOV [6],CL	@66 66 B8 FE 66 00	Set control register #%X by %Y
MOV [6],DL	@66 66 B8 FE 77 00	Set control register #%X by %Y
MOV [7],BH	@77 77 B8 FE 11 00	Set control register #%X by %Y
MOV [7],CH	@77 77 B8 FE 22 00	Set control register #%X by %Y
MOV [7],DH	@77 77 B8 FE 33 00	Set control register #%X by %Y
MOV [7],AL	@77 77 B8 FE 44 00	Set control register #%X by %Y
MOV [7],BL	@77 77 B8 FE 55 00	Set control register #%X by %Y
MOV [7],CL	@77 77 B8 FE 66 00	Set control register #%X by %Y
MOV [7],DL	@77 77 B8 FE 77 00	Set control register #%X by %Y
MOV BH,[0]	@11 00 B8 FE 00		Get control register #%Y to %X
MOV CH,[0]	@22 00 B8 FE 00		Get control register #%Y to %X
MOV DH,[0]	@33 00 B8 FE 00		Get control register #%Y to %X
MOV AL,[0]	@44 00 B8 FE 00		Get control register #%Y to %X
MOV BL,[0]	@55 00 B8 FE 00		Get control register #%Y to %X
MOV CL,[0]	@66 00 B8 FE 00		Get control register #%Y to %X
MOV DL,[0]	@77 00 B8 FE 00		Get control register #%Y to %X
MOV BH,[1]	@11 00 B8 FE 11 11	Get control register #%Y to %X
MOV CH,[1]	@22 00 B8 FE 11 11	Get control register #%Y to %X
MOV DH,[1]	@33 00 B8 FE 11 11	Get control register #%Y to %X
MOV AL,[1]	@44 00 B8 FE 11 11	Get control register #%Y to %X
MOV BL,[1]	@55 00 B8 FE 11 11	Get control register #%Y to %X
MOV CL,[1]	@66 00 B8 FE 11 11	Get control register #%Y to %X
MOV DL,[1]	@77 00 B8 FE 11 11	Get control register #%Y to %X
MOV BH,[2]	@11 00 B8 FE 22 22	Get control register #%Y to %X
MOV CH,[2]	@22 00 B8 FE 22 22	Get control register #%Y to %X
MOV DH,[2]	@33 00 B8 FE 22 22	Get control register #%Y to %X
MOV AL,[2]	@44 00 B8 FE 22 22	Get control register #%Y to %X
MOV BL,[2]	@55 00 B8 FE 22 22	Get control register #%Y to %X
MOV CL,[2]	@66 00 B8 FE 22 22	Get control register #%Y to %X
MOV DL,[2]	@77 00 B8 FE 22 22	Get control register #%Y to %X
MOV BH,[3]	@11 00 B8 FE 33 33	Get control register #%Y to %X
MOV CH,[3]	@22 00 B8 FE 33 33	Get control register #%Y to %X
MOV DH,[3]	@33 00 B8 FE 33 33	Get control register #%Y to %X
MOV AL,[3]	@44 00 B8 FE 33 33	Get control register #%Y to %X
MOV BL,[3]	@55 00 B8 FE 33 33	Get control register #%Y to %X
MOV CL,[3]	@66 00 B8 FE 33 33	Get control register #%Y to %X
MOV DL,[3]	@77 00 B8 FE 33 33	Get control register #%Y to %X
MOV BH,[4]	@11 00 B8 FE 44 44	Get control register #%Y to %X
MOV CH,[4]	@22 00 B8 FE 44 44	Get control register #%Y to %X
MOV DH,[4]	@33 00 B8 FE 44 44	Get control register #%Y to %X
MOV AL,[4]	@44 00 B8 FE 44 44	Get control register #%Y to %X
MOV BL,[4]	@55 00 B8 FE 44 44	Get control register #%Y to %X
MOV CL,[4]	@66 00 B8 FE 44 44	Get control register #%Y to %X
MOV DL,[4]	@77 00 B8 FE 44 44	Get control register #%Y to %X
MOV BH,[5]	@11 00 B8 FE 55 55	Get control register #%Y to %X
MOV CH,[5]	@22 00 B8 FE 55 55	Get control register #%Y to %X
MOV DH,[5]	@33 00 B8 FE 55 55	Get control register #%Y to %X
MOV AL,[5]	@44 00 B8 FE 55 55	Get control register #%Y to %X
MOV BL,[5]	@55 00 B8 FE 55 55	Get control register #%Y to %X
MOV CL,[5]	@66 00 B8 FE 55 55	Get control register #%Y to %X
MOV DL,[5]	@77 00 B8 FE 55 55	Get control register #%Y to %X
MOV BH,[6]	@11 00 B8 FE 66 66	Get control register #%Y to %X
MOV CH,[6]	@22 00 B8 FE 66 66	Get control register #%Y to %X
MOV DH,[6]	@33 00 B8 FE 66 66	Get control register #%Y to %X
MOV AL,[6]	@44 00 B8 FE 66 66	Get control register #%Y to %X
MOV BL,[6]	@55 00 B8 FE 66 66	Get control register #%Y to %X
MOV CL,[6]	@66 00 B8 FE 66 66	Get control register #%Y to %X
MOV DL,[6]	@77 00 B8 FE 66 66	Get control register #%Y to %X
MOV BH,[7]	@11 00 B8 FE 77 77	Get control register #%Y to %X
MOV CH,[7]	@22 00 B8 FE 77 77	Get control register #%Y to %X
MOV DH,[7]	@33 00 B8 FE 77 77	Get control register #%Y to %X
MOV AL,[7]	@44 00 B8 FE 77 77	Get control register #%Y to %X
MOV BL,[7]	@55 00 B8 FE 77 77	Get control register #%Y to %X
MOV CL,[7]	@66 00 B8 FE 77 77	Get control register #%Y to %X
MOV DL,[7]	@77 00 B8 FE 77 77	Get control register #%Y to %X
MOV BH,[BH]	@11 00 B8 FE 11 00	Read context cell [%X] to %X
MOV CH,[CH]	@22 00 B8 FE 22 00	Read context cell [%X] to %X
MOV DH,[DH]	@33 00 B8 FE 33 00	Read context cell [%X] to %X
MOV AL,[AL]	@44 00 B8 FE 44 00	Read context cell [%X] to %X
MOV BL,[BL]	@55 00 B8 FE 55 00	Read context cell [%X] to %X
MOV CL,[CL]	@66 00 B8 FE 66 00	Read context cell [%X] to %X
MOV DL,[DL]	@77 00 B8 FE 77 00	Read context cell [%X] to %X
MOV [BH],CH	@11 00 B8 FE 22 00	Write %Y to context cell [%X]
MOV [BH],DH	@11 00 B8 FE 33 00	Write %Y to context cell [%X]
MOV [BH],AL	@11 00 B8 FE 44 00	Write %Y to context cell [%X]
MOV [BH],BL	@11 00 B8 FE 55 00	Write %Y to context cell [%X]
MOV [BH],CL	@11 00 B8 FE 66 00	Write %Y to context cell [%X]
MOV [BH],DL	@11 00 B8 FE 77 00	Write %Y to context cell [%X]
MOV [CH],BH	@22 00 B8 FE 11 00	Write %Y to context cell [%X]
MOV [CH],DH	@22 00 B8 FE 33 00	Write %Y to context cell [%X]
MOV [CH],AL	@22 00 B8 FE 44 00	Write %Y to context cell [%X]
MOV [CH],BL	@22 00 B8 FE 55 00	Write %Y to context cell [%X]
MOV [CH],CL	@22 00 B8 FE 66 00	Write %Y to context cell [%X]
MOV [CH],DL	@22 00 B8 FE 77 00	Write %Y to context cell [%X]
MOV [DH],BH	@33 00 B8 FE 11 00	Write %Y to context cell [%X]
MOV [DH],CH	@33 00 B8 FE 22 00	Write %Y to context cell [%X]
MOV [DH],AL	@33 00 B8 FE 44 00	Write %Y to context cell [%X]
MOV [DH],BL	@33 00 B8 FE 55 00	Write %Y to context cell [%X]
MOV [DH],CL	@33 00 B8 FE 66 00	Write %Y to context cell [%X]
MOV [DH],DL	@33 00 B8 FE 77 00	Write %Y to context cell [%X]
MOV [AL],BH	@44 00 B8 FE 11 00	Write %Y to context cell [%X]
MOV [AL],CH	@44 00 B8 FE 22 00	Write %Y to context cell [%X]
MOV [AL],DH	@44 00 B8 FE 33 00	Write %Y to context cell [%X]
MOV [AL],BL	@44 00 B8 FE 55 00	Write %Y to context cell [%X]
MOV [AL],CL	@44 00 B8 FE 66 00	Write %Y to context cell [%X]
MOV [AL],DL	@44 00 B8 FE 77 00	Write %Y to context cell [%X]
MOV [BL],BH	@55 00 B8 FE 11 00	Write %Y to context cell [%X]
MOV [BL],CH	@55 00 B8 FE 22 00	Write %Y to context cell [%X]
MOV [BL],DH	@55 00 B8 FE 33 00	Write %Y to context cell [%X]
MOV [BL],AL	@55 00 B8 FE 44 00	Write %Y to context cell [%X]
MOV [BL],CL	@55 00 B8 FE 66 00	Write %Y to context cell [%X]
MOV [BL],DL	@55 00 B8 FE 77 00	Write %Y to context cell [%X]
MOV [CL],BH	@66 00 B8 FE 11 00	Write %Y to context cell [%X]
MOV [CL],CH	@66 00 B8 FE 22 00	Write %Y to context cell [%X]
MOV [CL],DH	@66 00 B8 FE 33 00	Write %Y to context cell [%X]
MOV [CL],AL	@66 00 B8 FE 44 00	Write %Y to context cell [%X]
MOV [CL],BL	@66 00 B8 FE 55 00	Write %Y to context cell [%X]
MOV [CL],DL	@66 00 B8 FE 77 00	Write %Y to context cell [%X]
MOV [DL],BH	@77 00 B8 FE 11 00	Write %Y to context cell [%X]
MOV [DL],CH	@77 00 B8 FE 22 00	Write %Y to context cell [%X]
MOV [DL],DH	@77 00 B8 FE 33 00	Write %Y to context cell [%X]
MOV [DL],AL	@77 00 B8 FE 44 00	Write %Y to context cell [%X]
MOV [DL],BL	@77 00 B8 FE 55 00	Write %Y to context cell [%X]
MOV [DL],CL	@77 00 B8 FE 66 00	Write %Y to context cell [%X]
IN BH		@11 11 B8 FE 11 11	Input to %X from port %X
IN CH		@22 22 B8 FE 22 22	Input to %X from port %X
IN DH		@33 33 B8 FE 33 33	Input to %X from port %X
IN AL		@44 44 B8 FE 44 44	Input to %X from port %X
IN BL		@55 55 B8 FE 55 55	Input to %X from port %X
IN CL		@66 66 B8 FE 66 66	Input to %X from port %X
IN DL		@77 77 B8 FE 77 77	Input to %X from port %X
OUT BH,CH	@11 11 B8 FE 22 22	Output %Y to port %X
OUT BH,DH	@11 11 B8 FE 33 33	Output %Y to port %X
OUT BH,AL	@11 11 B8 FE 44 44	Output %Y to port %X
OUT BH,BL	@11 11 B8 FE 55 55	Output %Y to port %X
OUT BH,CL	@11 11 B8 FE 66 66	Output %Y to port %X
OUT BH,DL	@11 11 B8 FE 77 77	Output %Y to port %X
OUT CH,BH	@22 22 B8 FE 11 11	Output %Y to port %X
OUT CH,DH	@22 22 B8 FE 33 33	Output %Y to port %X
OUT CH,AL	@22 22 B8 FE 44 44	Output %Y to port %X
OUT CH,BL	@22 22 B8 FE 55 55	Output %Y to port %X
OUT CH,CL	@22 22 B8 FE 66 66	Output %Y to port %X
OUT CH,DL	@22 22 B8 FE 77 77	Output %Y to port %X
OUT DH,BH	@33 33 B8 FE 11 11	Output %Y to port %X
OUT DH,CH	@33 33 B8 FE 22 22	Output %Y to port %X
OUT DH,AL	@33 33 B8 FE 44 44	Output %Y to port %X
OUT DH,BL	@33 33 B8 FE 55 55	Output %Y to port %X
OUT DH,CL	@33 33 B8 FE 66 66	Output %Y to port %X
OUT DH,DL	@33 33 B8 FE 77 77	Output %Y to port %X
OUT AL,BH	@44 44 B8 FE 11 11	Output %Y to port %X
OUT AL,CH	@44 44 B8 FE 22 22	Output %Y to port %X
OUT AL,DH	@44 44 B8 FE 33 33	Output %Y to port %X
OUT AL,BL	@44 44 B8 FE 55 55	Output %Y to port %X
OUT AL,CL	@44 44 B8 FE 66 66	Output %Y to port %X
OUT AL,DL	@44 44 B8 FE 77 77	Output %Y to port %X
OUT BL,BH	@55 55 B8 FE 11 11	Output %Y to port %X
OUT BL,CH	@55 55 B8 FE 22 22	Output %Y to port %X
OUT BL,DH	@55 55 B8 FE 33 33	Output %Y to port %X
OUT BL,AL	@55 55 B8 FE 44 44	Output %Y to port %X
OUT BL,CL	@55 55 B8 FE 66 66	Output %Y to port %X
OUT BL,DL	@55 55 B8 FE 77 77	Output %Y to port %X
OUT CL,BH	@66 66 B8 FE 11 11	Output %Y to port %X
OUT CL,CH	@66 66 B8 FE 22 22	Output %Y to port %X
OUT CL,DH	@66 66 B8 FE 33 33	Output %Y to port %X
OUT CL,AL	@66 66 B8 FE 44 44	Output %Y to port %X
OUT CL,BL	@66 66 B8 FE 55 55	Output %Y to port %X
OUT CL,DL	@66 66 B8 FE 77 77	Output %Y to port %X
OUT DL,BH	@77 77 B8 FE 11 11	Output %Y to port %X
OUT DL,CH	@77 77 B8 FE 22 22	Output %Y to port %X
OUT DL,DH	@77 77 B8 FE 33 33	Output %Y to port %X
OUT DL,AL	@77 77 B8 FE 44 44	Output %Y to port %X
OUT DL,BL	@77 77 B8 FE 55 55	Output %Y to port %X
OUT DL,CL	@77 77 B8 FE 66 66	Output %Y to port %X

ASCx0000 FF FF FF FF FF FF FF FF C7 C7 C7 C7 FF FF FF FF
ASCx0010 F8 F8 F8 F8 FF FF FF FF C0 C0 C0 C0 FF FF FF FF
ASCx0020 FF FF FF FF F8 F8 F8 F8 C7 C7 C7 C7 F8 F8 F8 F8
ASCx0030 F8 F8 F8 F8 F8 F8 F8 F8 C0 C0 C0 C0 F8 F8 F8 F8
ASCx0040 FF FF FF FF FF FF FF FF F3 F3 C0 D2 F3 F3 ED DE
ASCx0050 FF FF FF FF FF FF FF FF F3 E1 C0 F3 F3 F3 F3 F3
ASCx0060 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
ASCx0070 F7 F3 D1 C0 C0 D1 F3 F7 F3 F3 F3 F3 F3 C0 E1 F3
ASCx0080 FF FF FF FF C7 C7 C7 C7 C7 C7 C7 C7 C7 C7 C7 C7
ASCx0090 F8 F8 F8 F8 C7 C7 C7 C7 C0 C0 C0 C0 C7 C7 C7 C7
ASCx00A0 FF FF FF FF C0 C0 C0 C0 C7 C7 C7 C7 C0 C0 C0 C0
ASCx00B0 F8 F8 F8 F8 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0
ASCx00C0 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
ASCx00D0 FF FF FF FF FF FF FF FF F3 F3 F3 F3 F3 F3 F3 F3
ASCx00E0 FF FF FF C0 C0 FF FF FF FB F3 E2 C0 C0 E2 F3 FB
ASCx00F0 C7 DF DF D8 C2 FA FA FA FF FF FF FF FF FF FF FF
ASCx0100 FF FF FF FF FF FF FF FF FB FB FB FB FB FF FB FF
ASCx0110 F5 F5 F5 FF FF FF FF FF F5 F5 E0 F5 E0 F5 F5 FF
ASCx0120 FB F0 EB F1 FA E1 FB FF E7 E6 FD FB F7 EC FC FF
ASCx0130 FB F5 F5 F3 EA ED F2 FF F9 F9 FD FB FF FF FF FF
ASCx0140 FD FB F7 F7 F7 FB FD FF F7 FB FD FD FD FB F7 FF
ASCx0150 FF FB EA F1 EA FB FF FF FF FB FB E0 FB FB FF FF
ASCx0160 FF FF FF F3 F3 FB F7 FF FF FF FF E0 FF FF FF FF
ASCx0170 FF FF FF FF FF F3 F3 FF FF FE FD FB F7 EF FF FF
ASCx0180 F1 EE EC EA E6 EE F1 FF FB F3 FB FB FB FB F1 FF
ASCx0190 F1 EE FE F9 F7 EF E0 FF E0 FE FD F9 FE EE F1 FF
ASCx01A0 FD F9 F5 ED E0 FD FD FF E0 EF E1 FE FE EE F1 FF
ASCx01B0 F8 F7 EF E1 EE EE F1 FF E0 FE FD FB F7 F7 F7 FF
ASCx01C0 F1 EE EE F1 EE EE F1 FF F1 EE EE F0 FE FD E3 FF
ASCx01D0 FF F3 F3 FF FF F3 F3 FF F3 F3 FF F3 F3 FB F7 FF
ASCx01E0 FD FB F7 EF F7 FB FD FF FF FF E0 FF E0 FF FF FF
ASCx01F0 F7 FB FD FE FD FB F7 FF F1 EE FE FD FB FF FB FF
ASCx0200 F1 EE EC EA E8 EF F1 FF FB F5 EE EE E0 EE EE FF
ASCx0210 E1 EE EE E1 EE EE E1 FF F1 EE EF EF EF EE F1 FF
ASCx0220 E1 F6 F6 F6 F6 F6 E1 FF E0 EF EF E1 EF EF E0 FF
ASCx0230 E0 EF EF E1 EF EF EF FF F1 EE EF EF EC EE F0 FF
ASCx0240 EE EE EE E0 EE EE EE FF F1 FB FB FB FB FB F1 FF
ASCx0250 FE FE FE FE EE EE F1 FF EE ED EB E7 EB ED EE FF
ASCx0260 EF EF EF EF EF EE E0 FF EE E4 EA EA EE EE EE FF
ASCx0270 EE EE E6 EA EC EE EE FF F1 EE EE EE EE EE F1 FF
ASCx0280 E1 EE EE E1 EF EF EF FF F1 EE EE EE EA ED F2 FF
ASCx0290 E1 EE EE E1 EB ED EE FF F1 EE EF F1 FE EE F1 FF
ASCx02A0 E0 FB FB FB FB FB FB FF EE EE EE EE EE EE F1 FF
ASCx02B0 EE EE EE F5 F5 FB FB FF EE EE EE EA EA EA F5 FF
ASCx02C0 EE EE F5 FB F5 EE EE FF EE EE F5 FB FB FB FB FF
ASCx02D0 E0 FE FD F1 F7 EF E0 FF F1 F7 F7 F7 F7 F7 F1 FF
ASCx02E0 FF EF F7 FB FD FE FF FF F1 FD FD FD FD FD F1 FF
ASCx02F0 F1 EE FF FF FF FF FF FF FF FF FF FF FF FF E0 FF
ASCx0300 ED EA EA E2 EA EA ED FF FB F5 EE EE E0 EE EE FF
ASCx0310 E0 EF EF E1 EE EE E1 FF ED ED ED ED ED E0 FE FF
ASCx0320 F9 F5 F5 F5 F5 E0 EE FF E0 EF EF E1 EF EF E0 FF
ASCx0330 FB E0 EA EA E0 FB FB FF E0 EE EF EF EF EF EF FF
ASCx0340 EE EE F5 FB F5 EE EE FF EE EE EC EA E6 EE EE FF
ASCx0350 EA EE EC EA E6 EE EE FF EE ED EB E7 EB ED EE FF
ASCx0360 F8 F6 F6 F6 F6 F6 F6 FF EE E4 EA EA EE EE EE FF
ASCx0370 EE EE EE E0 EE EE EE FF F1 EE EE EE EE EE F1 FF
ASCx0380 E0 EE EE EE EE EE EE FF F0 EE EE F0 FA F6 EE FF
ASCx0390 E1 EE EE E1 EF EF EF FF F1 EE EF EF EF EE F1 FF
ASCx03A0 E0 FB FB FB FB FB FB FF EE EE EE F5 FB F7 EF FF
ASCx03B0 EE EA EA F1 EA EA EE FF E1 EE EE E1 EE EE E1 FF
ASCx03C0 EF EF EF E1 EE EE E1 FF EE EE EE E6 EA EA E6 FF
ASCx03D0 F1 EE EE F9 FE EE F1 FF EE EA EA EA EA EA E0 FF
ASCx03E0 F1 EE FE F8 FE EE F1 FF EA EA EA EA EA E0 FE FF
ASCx03F0 EE EE EE E0 FE FE FE FF C0 C0 C0 C0 C0 C0 C0 FF
ASCx0400 FF FF FF FF FF FF FF FF C7 C7 C7 C7 FF FF FF FF
ASCx0410 F8 F8 F8 F8 FF FF FF FF C0 C0 C0 C0 FF FF FF FF
ASCx0420 FF FF FF FF F8 F8 F8 F8 C7 C7 C7 C7 F8 F8 F8 F8
ASCx0430 F8 F8 F8 F8 F8 F8 F8 F8 C0 C0 C0 C0 F8 F8 F8 F8
ASCx0440 FF FF FF FF FF FF FF FF F3 F3 C0 D2 F3 F3 ED DE
ASCx0450 FF FF FF FF FF FF FF FF F3 E1 C0 F3 F3 F3 F3 F3
ASCx0460 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
ASCx0470 F7 F3 D1 C0 C0 D1 F3 F7 F3 F3 F3 F3 F3 C0 E1 F3
ASCx0480 FF FF FF FF C7 C7 C7 C7 C7 C7 C7 C7 C7 C7 C7 C7
ASCx0490 F8 F8 F8 F8 C7 C7 C7 C7 C0 C0 C0 C0 C7 C7 C7 C7
ASCx04A0 FF FF FF FF C0 C0 C0 C0 C7 C7 C7 C7 C0 C0 C0 C0
ASCx04B0 F8 F8 F8 F8 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0
ASCx04C0 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
ASCx04D0 FF FF FF FF FF FF FF FF F3 F3 F3 F3 F3 F3 F3 F3
ASCx04E0 FF FF FF C0 C0 FF FF FF FB F3 E2 C0 C0 E2 F3 FB
ASCx04F0 C7 DF DF D8 C2 FA FA FA FF FF FF FF FF FF FF FF
ASCx0500 FF FF FF FF FF FF FF FF FB FB FB FB FB FF FB FF
ASCx0510 F5 F5 F5 FF FF FF FF FF F5 F5 E0 F5 E0 F5 F5 FF
ASCx0520 FB F0 EB F1 FA E1 FB FF E7 E6 FD FB F7 EC FC FF
ASCx0530 FB F5 F5 F3 EA ED F2 FF F9 F9 FD FB FF FF FF FF
ASCx0540 FD FB F7 F7 F7 FB FD FF F7 FB FD FD FD FB F7 FF
ASCx0550 FF FB EA F1 EA FB FF FF FF FB FB E0 FB FB FF FF
ASCx0560 FF FF FF F3 F3 FB F7 FF FF FF FF E0 FF FF FF FF
ASCx0570 FF FF FF FF FF F3 F3 FF FF FE FD FB F7 EF FF FF
ASCx0580 F1 EE EC EA E6 EE F1 FF FB F3 FB FB FB FB F1 FF
ASCx0590 F1 EE FE F9 F7 EF E0 FF E0 FE FD F9 FE EE F1 FF
ASCx05A0 FD F9 F5 ED E0 FD FD FF E0 EF E1 FE FE EE F1 FF
ASCx05B0 F8 F7 EF E1 EE EE F1 FF E0 FE FD FB F7 F7 F7 FF
ASCx05C0 F1 EE EE F1 EE EE F1 FF F1 EE EE F0 FE FD E3 FF
ASCx05D0 FF F3 F3 FF FF F3 F3 FF F3 F3 FF F3 F3 FB F7 FF
ASCx05E0 FD FB F7 EF F7 FB FD FF FF FF E0 FF E0 FF FF FF
ASCx05F0 F7 FB FD FE FD FB F7 FF F1 EE FE FD FB FF FB FF
ASCx0600 EF F7 FB FF FF FF FF FF FF FF F1 ED ED ED F2 FF
ASCx0610 F7 F7 F1 F6 F6 F6 F1 FF FF FF F8 F7 F7 F7 F8 FF
ASCx0620 FE FE F8 F6 F6 F6 F8 FF FF FF F9 F6 F1 F7 F8 FF
ASCx0630 F9 F6 F7 E3 F7 F7 F7 FF FF FF F8 F6 F8 FE F1 FF
ASCx0640 F7 F7 F1 F6 F6 F6 F6 FF FD FF F9 FD FD FD F8 FF
ASCx0650 FE FF FE FE FE F6 F9 FF F7 F7 F6 F5 F3 F5 F6 FF
ASCx0660 F9 FD FD FD FD FD F8 FF FF FF E5 EA EA EA EA FF
ASCx0670 FF FF F1 F6 F6 F6 F6 FF FF FF F9 F6 F6 F6 F9 FF
ASCx0680 FF FF F1 F6 F6 F1 F7 FF FF FF F8 F6 F6 F8 FE FF
ASCx0690 FF FF F1 F6 F7 F7 F7 FF FF FF F8 F7 F9 FE F1 FF
ASCx06A0 F7 F7 E3 F7 F7 F6 F9 FF FF FF EE EE EE EE F1 FF
ASCx06B0 FF FF EE EE EE F5 FB FF FF FF EE EE EA EA F5 FF
ASCx06C0 FF FF EE F5 FD F5 EE FF FF FF F6 F6 F8 FE F1 FF
ASCx06D0 FF FF F0 FE F9 F7 F0 FF FE FD FD FB FD FD FE FF
ASCx06E0 F7 F7 F7 FF F7 F7 F7 FF EF F7 F7 FB F7 F7 EE FF
ASCx06F0 FF FF F7 F3 F0 FC FE FF F7 F3 E1 C0 E1 F3 FB FF
ASCx0700 FF FF ED EA E2 EA ED FF FF FF F1 FE F8 F6 F9 FF
ASCx0710 FF FF F8 F7 F1 F6 F1 FF FF FF ED ED ED ED E0 FE
ASCx0720 FF FF F9 F6 F8 FE F0 FF FF FF F9 F6 F1 F7 F8 FF
ASCx0730 FF FF FB F1 EA F1 FB FB FF FF F0 F7 F7 F7 F7 FF
ASCx0740 FF FF F6 F9 F9 F6 F6 FF FF FF F6 F6 F4 F2 F6 FF
ASCx0750 F9 FF F6 F6 F4 F2 F6 FF FF FF F6 F5 F3 F5 F6 FF
ASCx0760 FF FF FC FA F6 F6 F6 FF FF FF EE E4 EA EA EE FF
ASCx0770 FF FF F6 F6 F0 F6 F6 FF FF FF F9 F6 F6 F6 F9 FF
ASCx0780 FF FF F0 F6 F6 F6 F6 FF FF FF F8 F6 F8 FA F6 FF
ASCx0790 FF FF F1 F6 F1 F7 F7 F7 FF FF F8 F7 F7 F7 F8 FF
ASCx07A0 FF FF E0 FB FB FB FB FF FF FF F6 F6 F8 FE F1 FF
ASCx07B0 FF FF EA EA F1 EA EA FF FF FF F1 F6 F1 F6 F1 FF
ASCx07C0 FF FF F7 F7 F1 F6 F1 FF FF FF EE EE E6 EA E6 FF
ASCx07D0 FF FF F9 F6 FD FE F1 FF FF FF EA EA EA EA E0 FF
ASCx07E0 FF FF F1 FE F8 FE F1 FF FF FF D5 D5 D5 D5 C0 FE
ASCx07F0 FF FF F6 F6 F0 FE FE FF FF E7 E7 81 81 E7 E7 FF
</var>
<table><tr valign=top>
<td colspan=2><pre id=Triggers style=position:absolute></pre><pre style=position:absolute><br />
 <textarea id=Assm rows=28 cols=108 style=visibility:hidden>
Intuitive clear mnemonic to quick memorize:
|Codes|Key|Elementary description__________
  00  :Nil-Null of instructions queue / HLT
xA..xB:A/B-Add / Subtract
xC..xD:C/D-Conjunction / Disjunction
  xE  : E -Exclusive bitwise OR
A0..A7: A -Access to bytes
A8..AF:A/A-Access to ALU
B0..B7: B -Branches to nearest substitutes
B8..BF:B/F-Branches to near labels by flags
C0..C7: C -Increment
  CA  :RAL-Concatenate Access roll
  CF  :C/F-Complement for Carry Flag
D0..D7: D -Decrement
  DA  :RAR-Descended Access roll
  DF  :D/F-Data Formation by NOT
+EC/ED:Exclude operations by Counter/Data
F0..F9:F/x-Functions of BIOS-API
+FC/FD:Forcing operation by Counter/Data
  FE  :F/E-Fiction Execute / NOP
  FF  :F/F-Finalize the Function / RET
Simplest protection from errors in code:
Examples|Macros||Codes|Description 
BE FF   |RZ    ||B2 FE|Microcode#4 
BF FF   |RNZ   ||B2 FF|Microcode#5 
BE FE   |REPZ  ||B3 FE|Microcode#6-
BF FE   |REPNZ ||B6 FF|Microcode#14
CF BC FD|CLC   ||B7 FE|Microcode#15
CF BD FD|STC   ||B7 FF|Microcode#16
</textarea><br />
</pre><pre id='Instructions'></pre><input id=KeyBoard size=118 value='D000,3BF`MH`MI`M' type=text accessKey=K  title='keyboard buffer [ALT+K]' onblur='cpu.watch.active=""' onfocus='cpu.watch.active="K"' /><span id=Context></span></td>
<!--pre id='commands'></pre></td-->
<td rowspan=2>
<pre id=Disassembly></pre>
<nobr><input id=Address size=13 style=color:cyan value='' type=text accessKey=P title='Pointer/Poking data [ALT+P]' onblur='cpu.watch.active=""' onfocus='cpu.watch.active="P"'
/><input id=Mnemonic size=27 style=color:lightgreen value='' type=text accessKey=T title='Translation/Translator [ALT+T]' onblur='cpu.watch.active=""' onfocus='cpu.watch.active="T"'
/><input id=Remark size=37 style=color:yellow value='' type=text accessKey=R title='Remark/Remote [ALT+R]' onblur='cpu.watch.active=""' onfocus='cpu.watch.active="R"' /></nobr>
<pre id=FILE:Xonix style=display:none>
	ORG	0x0000
Xonix:	
	RET
</pre>
<pre id=FILE:Tetris style=display:none>
	ORG	0x0000
Tetris:
	RET</pre>
<pre id=BootSection style=display:none
alt='.0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F'><!--

;F810:11 BF FF 11 BF 01 00 00 77 BF FF 77 BF 01
;F820:22 BF FF 22 BF 01 00 00 66 BF FF 66 BF 01
;F830:33 BF FF 33 BF 01 00 00 55 BF FF 55 BF 01
;F840:44 BF FF 44 BF 01 00 00
;    Seq   Blank  X  Y SX SY PX PY BELL SCREEN Mul78
;7650:00 00 00 00 00 00 41 19 08 03 F0 05 D0 76 E7 FD
;       Val   Page
;7660:DE FD CC FD 50 76
;  ansistd outstd
;F800:A4 7F A5 02 5A
;	F0
;	5A
;	F0
;	5A
-->	DEBUG	0x00
	ORG	0x0000
Zeroed:	PUSH	0x0015
	POP	BX
	MOV	CL,0x09
	LOOP	CL
	ADD	BX,BX
	MOV	AL,0x01
	LOOP	7
	RCL	AL
	SKIP	3
	DEC	AL
	DEC	AL
	DEC	AL
	DEC	AL
	NOP
	ADD	BX,BX
	MOV	AL,0x80
	MOV	CL,0x03
	HLT	CL
	STR
	MOV	AL,0x81
	MOV	CL,0x03
	HLT	CL
	STB
	MOV	AL,0x82
	MOV	CL,0x03
	HLT	CL
	SKIP
	INC	AL
	INC	AL
	INC	AL
	INC	AL
	MOV	AL,0x83
	MOV	CL,0x03
	HLT	CL
	SKIB
	INC	AL
	INC	AL
	INC	AL
	INC	AL
	MOV	AL,0x84
	MOV	CL,0x03
	HLT	CL
	REP
	INC	AL
	MOV	AL,0x85
	MOV	CL,0x03
	HLT	CL
	REB
	INC	AL
	;;;;;;;;;;;;;;;;;
	ORG	0xE000
INT_XX:	XCHG	BX,[SP]
	PUSH	AX
	MOV	AL,[BX]
	LOOP	4
	RCR	AL
	JS	.basic
	CMP	AL,[BX]
	JNZ	.basic
	MOV	AL,[BX+1]
	SUB	AL,0xF0
	JC	.other
	CMP	AL,0x0A
	JNC	.other
	MOV	AL,[BX]
	INC	BX
	SKIP	[AL]
	NOP
	JMP	.memory
	JMP	.string
	JMP	.audio
	JMP	.data
	JMP	.unic
	JMP	.file
	JMP	.window
.basic:	MOV	AL,[BX]
	SUB	AL,0xF0
	JC	.other
	CMP	AL,0x0A
	JNC	.other
	SKIP	AL
	JMP	.x0
	JMP	.x1
	JMP	.x2
	JMP	.x3
	JMP	.x4
	JMP	.x5
	JMP	.x6
	JMP	.x7
	JMP	.x8
	JMP	.x9
.memory:NOP	1
.string:NOP	2
.audio:	NOP	3
.data:	NOP	4
.unic:	NOP	5
.file:	NOP	6
	BIAS	.exit
	RET
.other:	NOP
	JMP	.other
.window:MOV	AL,[BX]
	INC	BX
	AND	AL,0x0F
	SKIP	AL
	JMP	.exit
	JMP	.putc
	JMP	.putxt
	JMP	.getc
	JMP	.exit
	JMP	.puthx
	JMP	.exit
	JMP	.exit
	JMP	.exit
	JMP	.exit
.putc:	POP	AX
	XCHG	BX,[SP]
	PUSH	BIOS.PutChr
	RET
.putxt:	HLT	BX
	PUSH	BIOS.PutMsg
	XCHG	IP,[SP]
	POP	AX
	XCHG	BX,[SP]
	RET
.getc:	POP	AX
	XCHG	BX,[SP]
	PUSH	BIOS.GetChar
	RET
.puthx:	POP	AX
	XCHG	BX,[SP]
	PUSH	BIOS.PutHex
	RET
.exit:	NOP
	JMP	.exit
INTS:	XCHG	BX,[SP]
	PUSH	DX
	PUSH	AX
	MOV	DL,[BX]
	AND	DL,DL
	JZ	.halt
	INC	BX
	MOV	DH,DL
	LOOP	4
	RCR	DH
	CMP	DL,DH
	JNZ	.lo
	AND	DH,0x0F
	CMP	DH,0x08
	JNC	.lo
	MOV	DL,[BX]
	INC	BX
.lo:	CMP	DL,0xFA
	JNC	.hard
	SUB	DL,0xF0
	JC	.hard
	HLT	DH
	CALL	.switch
	DW	.basic
	DW	.memory
	DW	.string
	DW	.audio
	DW	.data
	DW	.unic
	DW	.file
	DW	.window
.basic:	NOP
.memory:NOP	1
.string:NOP	2
.audio:	NOP	3
.data:	NOP	4
.unic:	NOP	5
.file:	NOP	6
	BASE	.exit
	RET
; 77+F0:
; 77+F1:
; 77+F2:AL=IsChar()
; 77+F3:AL=GetChr()
; 77+F4:
; 77+F5:PutHex(AL)
; 77+F6:
; 77+F7:
; 77+F8:PutMsg(BX)
; 77+F9:PutChr(CL)
.window:SKIP	[DL]
	JMP	.exit
	JMP	..putc
	JMP	..putxt
	JMP	..getc
	JMP	.exit
	JMP	.exit
	JMP	.exit
	JMP	.exit
..putc:	POP	AX,DX		; 77 F1
	XCHG	BX,[SP]
	PUSH	BIOS.PutChr
	RET
..putxt:POP	AX,DX		; 77 F2
	HLT	BX
	PUSH	BIOS.PutMsg
	XCHG	IP,[SP]
	XCHG	BX,[SP]
	RET
..getc:	POP	AX,DX		; 77 F3
	XCHG	BX,[SP]
	PUSH	BIOS.GetChar
	RET
.exit:	POP	AX,DX
	XCHG	BX,[SP]
	RET
.hard:	POP	AX,DX
	XCHG	BX,[SP]
	RET
.halt:	POP	AX,DX
	INT	72
	DB	"\r\nHALT AT \0"
	HLT	BX
	PUSH	BIOS.PutPtr
	XCHG	IP,[SP]
	PUSH	BIOS.Prompt
	RET
.switch:XCHG	BX,[SP]
	XCHG	AL
	ADD	AL,AL
	LEA	BX,BX+AL
	XCHG	AL
	PUSH	[BX+0x00]
	POP	BX
	XCHG	BX,[SP]
	RET
;;;;;;;;;;;;;;;;;;;;;;;
	ORG	0x1000

;;;;;;;;;;;;;;;;;;;;;;;
	ORG	0x0100
USER:	; USER API BY INT 0-9
	RET
	DEBUG	0x1
	ORG	0xF7FF
	NOP
	;;;;;;;;;;;;;;;
	ORG	0xF000
TIMER:	MOV	BH,0x77
	MOV	BL,0x1E
	XCHG	SP,BX
.x_____:MOV	BL,0x30
._x____:MOV	BH,0x30
.__x___:MOV	CL,0x30
.___x__:MOV	CH,0x30
.____x_:MOV	DL,0x30
._____x:MOV	DH,0x30
	MOV	AL,0xFF
.______:PUSH	DX,CX
	PUSH	BX
	POP	[SP]
	POP	[SP]
	POP	[SP]
	DEC	AL
	JNZ	.______
	MOV	AL,0x39
	INC	DH
	CMP	AL,DH
	JNC	.______
	INC	DL
	CMP	AL,DL
	JNC	._____x
	INC	CH
	CMP	AL,CH
	JNC	.____x_
	INC	CL
	CMP	AL,CL
	JNC	.___x__
	INC	BH
	CMP	AL,BH
	JNC	.__x___
	INC	BL
	CMP	AL,BL
	JNC	._x____
	JMP	.x_____
	;;;;;;;;;;;;;;;
	ORG	0xF600
SPEEDO:	SKIP	5
	MOV	AL,CL
	XOR	AL,[BX]
	MOV	[BX],AL
	DEC	BX
	CMP	DH,BH
	MOV	DH,0x76
	MOV	DL,0xD4
	XCHG	SP,DX
.x___:	MOV	CL,0x30
._x__:	MOV	CH,0x30
.__x_:	MOV	BL,0x30
.___x:	MOV	BH,0x30
.____:	XOR	AL,AL
	MOV	DH,AL
	MOV	DL,AL
	ADD	DX,SP
	PUSH	BX,CX
	MOV	BH,0x7F
	MOV	BL,0xF3
	MOV	CL,0x7F
.loop:	XOR	AL,AL
	;CMC
	HLT	7
	WAIT
	NOP	5
	CMP	BH,DH
	JNZ	.loop
	POP	CX,BX
	MOV	AL,0x39
	INC	BH
	CMP	AL,BH
	JNC	.____
	INC	BL
	CMP	AL,BL
	JNC	.___x
	INC	CH
	CMP	AL,CH
	JNC	.__x_
	INC	CL
	CMP	AL,CL
	JNC	._x__
	JMP	.x___
	;;;;;;;;;;;;;;;;;
	ORG	0xF700
SPEEDY:	MOV	DH,0x76
	MOV	DL,0xD4
	XCHG	SP,DX
.x___:	MOV	CL,0x30
._x__:	MOV	CH,0x30
.__x_:	MOV	BL,0x30
.___x:	MOV	BH,0x30
.____:	XOR	AL,AL
	MOV	DH,AL
	MOV	DL,AL
	ADD	DX,SP
	PUSH	BX,CX
	MOV	BH,0x7F
	MOV	BL,0xF3
.loop:	MOV	AL,[BX]
	XOR	AL,0x7F
	MOV	[BX],AL
	DEC	BX
	CMP	BL,DL
	JNC	.loop
	CMP	BH,DH
	JNZ	.loop
	POP	CX,BX
	MOV	AL,0x39
	INC	BH
	CMP	AL,BH
	JNC	.____
	INC	BL
	CMP	AL,BL
	JNC	.___x
	INC	CH
	CMP	AL,CH
	JNC	.__x_
	INC	CL
	CMP	AL,CL
	JNC	._x__
	JMP	.x___
	;;;;;;;;;;;;;;;;;
	ORG	0xF300
Help:
.List:	DB	"\n[A]BAC - CALCULATOR\r"
	DB	"\n[B]OOT - DOS-BOOTER\r"
	DB	"\n[C]OPY - COPY MEMORY\r"
	DB	"\n[D]UMP - DUMP OF MEMORY\r"
	DB	"\n[E]DIT - EDIT DUMP\r"
	DB	"\n[F]IND - FIND IN MEMORY\r"
	DB	"\n[G]OTO - GOTO ADDRESS\r"
	DB	"\n[I]DLE - STREAM ECHO\r"
	DB	"\n[J]OIN - JOIN\r"
	DB	"\n[K]EEP - KEEP\r"
	DB	"\n[L]IST - FILE LIST\r"
	DB	"\n[M]OVE - MOVE MEMORY DATA\r"
	DB	"\n[N]OTE - NOTE\r"
	DB	"\n[O]PEN - OPEN\r"
	DB	"\n[Q]UIT - REBOOT\r"
	DB	"\n[R]EAD - READ\r"
	DB	"\n[S]AVE - SAVE\r"
	DB	"\n[T]EXT - TEXT\r"
	DB	"\n[U]NIT - DEVICES LIST\r"
	DB	"\n[V]ANE - CPU FANS OUT\r"
	DB	"\n[W]AVE - WAVE\r"
	DB	"\n[X]TRA - EXTRA\r"
	DB	"\n[Y]AMP - Y-AMPLITUDE\r"
	DB	"\n[Z]ERO - CLEAR MEMORY\0"
	ORG	0xF800
BIOS:	MOV	BH,0x76
	MOV	BL,0xCE
	XCHG	SP,BX
	PUSH	0x7600
	POP	BP
	PUSH	0xE000
	POP	BX
	INT	72
	DB	"\_X80-BIOS V0.1\0"
.prompt:
	PUSH	BX
	MOV	BH,0x76
	MOV	BL,0xCE
	XCHG	SP,BX
	PUSH	0x7600
	POP	BP
	;
	INT	72
	DB	"\r\n/>\0"
..cmd:	INT	73
	CMP	AL,0x5B
	JNC	..cmd
	MOV	CL,AL
	SUB	AL,0x41
	JC	..cmd
	HLT	CL
	INT	71
	PUSH	.words
	POP	BX
	ADD	AL,AL
	ADD	AL,AL
	MOV	DL,AL
	XOR	DH,DH
	LEA	BX,DX+BX
	PUSH	[BX+2]
	PUSH	[BX+0]
	POP	BX
	MOV	CL,0x03
..loop:	MOV	AL,BH
	ROR	AL
	ROR	AL
	AND	AL,0x1F
	ADD	AL,0x40
	HLT	AL
	INT	71
	LOOP	5
	ADD	BX,BX
	DEC	CL
	JNZ	..loop
	POP	DI
	HLT	AL
	MOV	AL,0x20
	INT	71
	PUSH	..hexas
	POP	SI
	XOR	CH,CH
	MOV	CL,0x01
..hexa:	PUSH	[SI+0x00]
	POP	BX
	MOV	AL,CH
	AND	AL,CL
	ADD	AL,0xFF
	PUSH	.GetHex
	XCHG	IP,[SP]
	SBB	DL,DL
	CMP	AL,0x0D
	JZ	..next
	CMP	AL,0x1B
	JZ	.prompt
	CMP	AL,0x7F
	JNZ	..next
	NOT	CH
	OR	CH,CL
	NOT	CH
	RAR	CL
	AND	CL,CL
	;JZ	.prompt
	;CMP	CL,0x01
	JZ	..hexa
	MOV	AL,CH
	AND	AL,CH
	JZ	..clr
	MOV	AL,0x08
	HLT	AL
	INT	72
	DB	"\< \<\0";>
	CMP	CL,0x01
	JZ	..hexa
..clr:	XCHG	SI,BX
	DEC	BX
	DEC	BX
	XCHG	SI,BX
	JNZ	..hexa
..next:	HLT	AL
	INT	71
	ADD	DL,DL
	JNC	..next1
	PUSH	BX
	POP	[SI+0x00]
	XCHG	SI,BX
	INC	BX
	INC	BX
	XCHG	SI,BX
	OR	CH,CL
..next1:ADD	CL,CL
	CMP	AL,0x0D
	JNZ	..hexa
..exec:	PUSH	..hexas
	POP	SI
	PUSH	[SI+0x04]
	PUSH	[SI+0x02]
	PUSH	[SI+0x00]
	MOV	AL,CH
	ADD	AL,CL
	ADD	AL,CL
	POP	BX,DX
	POP	CX
	PUSH	DI
	XCHG	IP,[SP]
	XOR	AL,AL
	JZ	.prompt
	NOP	7
	SBB	DL,DL
	CMP	AL,0x7F
	XOR	AL,AL
	JZ	.prompt
	INT	71
	PUSH	0x76D0
	PUSH	0x78FF
	POP	DX,BX
	PUSH .HexDmp
	XCHG IP,[SP]
	PUSH .hello
	POP BX
	PUSH .PutMsg
	HLT BX
	XCHG IP,[SP]
	PUSH .PutPtr
	XCHG IP,[SP]
;	MOV	DL,0x08
;	MOV	DH,0x06
;	INT	71
;	INT	9S
;	HLT	3
..hexas:DW	0x0000
	DW	0x0000
	DW	0x0000
	DW	0x0000
	DW	0x0000
	DW	0x0000
	DW	0x0000
	DW	0x0000
.loopy:	PUSH	.PutChr
	PUSH	.GetChar
	XCHG	IP,[SP]
	HLT	AL
	XCHG	IP,[SP]
	CMP	AL,0x60
	;JZ	.stop
	CMP	AL,0x0D
	JNZ	.loopy
	INT	72
	DW	0x0808
	DW	0x0808
	DB	0x08
	DB	":\0"
	PUSH	TX
	POP	BX
	PUSH	.PutPtr
	XCHG	IP,[SP]
	JMP	.loopy
.stop:	PUSH?	BIOS.API.fn
	XCHG	IP,[SP]
	HLT
	HLT
	NOP	5
.hello:	DB	"\h\^\^BIOS\r\n/>\0"
.words:	DW	0x0823,..none	;ABAC
	DW	0x3DF4,..none	;BOOT
	DW	0x3E19,..none	;COPY
	DW	0x55B0,.HexDmp	;DUMP
	DW	0x1134,..none	;EDIT
	DW	0x25C4,..none	;FIND
	DW	0x3E8F,..Goto	;GOTO
	DW	0x1590,..Help	;HELP
	DW	0x1185,..Idle	;IDLE
	DW	0x3D2E,..none	;JOIN
	DW	0x14B0,..none	;KEEP
	DW	0x2674,..List	;LIST
	DW	0x3EC5,..none	;MOVE
	DW	0x3E85,..none	;NOTE
	DW	0x40AE,..none	;OPEN
	DW	0x3039,..none	;PLAY
	DW	0x5534,0xF800	;QUIT
	DW	0x1424,..none	;READ
	DW	0x06C5,..none	;SAVE
	DW	0x1714,..none	;TEXT
	DW	0x3934,..none	;UNIT
	DW	0x05C5,..none	;VANE
	DW	0x06C5,..none	;WAVE
	DW	0x5241,..xtra	;XTRA
	DW	0x06F0,..pan	;YAwP
	DW	0x164F,..Zero	;ZERO
..pan:	SKIP	5
	MOV	DL,AL
	MOV	AL,[BX]
	MOV	[BX],DL
	ADD	BX,CX
	CMC
	WAIT
	INT	50
	MOV	BH,0x7F
	MOV	BL,0XF3
	MOV	CH,0xFF
	MOV	CL,0xB2
...loop:PUSH	BX
	MOV	DH,0x4E
...rows:PUSH	DX,BX
	MOV	DH,0x1E
	HLT	DH
	WAIT
	INT	0
	POP	BX,DX
	DEC	BX
	DEC	DH
	JNZ	...rows
	POP	BX
	JMP	...loop
;;;;;;;;;;;;;;;;;;;;;;;;;
..Edit:	INT	72
	DB	"\r\n"
..Goto:	PUSH	BX
	RET
..Help:	PUSH	Help.List
	POP	BX
	HLT	BX
	PUSH	BIOS.PutMsg
	RET
..none:	INT	72
	DB	"\n!!! RESERVED DIRECTIVE\0"
	RET
..xtra:	XCHG	SP,BX
	LOOP	DL
	PUSH	EX
	XCHG	SP,BX
	RET
..List:	PUSH	.FileIn
	RET
..Zero:	
..Idle:	INT	73
	CMP	AL,0x1B
	RZ
	HLT	AL
	INT	71
	JNZ	..Idle
.GetHex:PUSH	CX
	SBB	CH,CH
	JC	..addr
..inkey:INT	73
	CMP	AL,0x08
	JZ	..back
	CMP	AL,0x20
	JZ	..addr
	CMP	AL,0x30
	JC	..exit
	CMP	AL,0x7F
	JZ	..clear
	CMP	AL,0x47
	JNC	..exit
	CMP	AL,0x3A
	JC	..nibble
	CMP	AL,0x41
	JC	..exit
	SUB	AL,0x07
..nibble:AND	AL,0x0F
	LOOP	4
	ADD	BX,BX
	OR	BL,AL
..addr:	AND	CH,CH
	JZ	..ptr
	INT	72
	DB	"\<\<\<\<\0";>
..ptr:	HLT	BX
	PUSH	.PutPtr
	XCHG	IP,[SP]
	OR	CH,0xFF
	JNZ	..inkey
..exit:	ADD	CH,CH
	POP	CX
	RET
..clear:ADD	CH,CH
	POP	CX
	RNC
	INT	72
	DB	"\< \<\< \<\< \<\< \<\0";>
	AND	AL,AL
	RET
..back:	HLT	BH
	XCHG
	HLT	BL
	XCHG
	XCHG	BL,BH
	LOOP	4
	ADD	BX,BX
	XCHG	BL,BH
	HLT	BH
	XCHG
	HLT	BL
	XCHG
	AND	BL,BL
	JMP	..addr
	;;;;;;;;;;;;;;;;;;
.MulBxD:
	;;;;;;;;;;;;;;;;;;
.TestBX:CMP	BL,DL
	RNZ
	CMP	BH,DH
	RET
.HexDmp:PUSH	BX,AX
..addr:	HLT	BX
	CALL	.PutPtr
	AND	BL,0xF0
..loop:	MOV	AL,0x20
	HLT	AL
	CALL	.PutChr
	MOV	AL,[BX]
	CALL	.PutHex
	CALL	.TestBX
	JZ	..end
	INC	BX
	MOV	AL,BL
	AND	AL,0x0F
	JNZ	..loop
	MOV	AL,0x0D
	CALL	.PutChr
	MOV	AL,0x0A
	CALL	.PutChr
	JZ	..addr
..end:	POP	AX,BX
	RET

.PutMsg:PUSH	BX,AX
	PUSH
	POP	BX
	HLT	AL
..loop:	MOV	AL,[BX]
	INC	BX
	AND	AL,AL
	CNZ	.PutChr
	JNZ	..loop
	POP	AX
	XCHG	BX,[SP]
	POP
	RET
.PutPtr:PUSH	BX,AX
	PUSH
	POP	BX
	HLT	AL
	PUSH	.PutHex
	PUSH	[SP+0x00]
	MOV	AL,BH
	XCHG	IP,[SP]
	MOV	AL,BL
	XCHG	IP,[SP]
	POP	AX,BX
	RET
.PutHex:PUSH	AX
	PUSH	.PutChr.reada
	XCHG	AL
	PUSH	AX
	LOOP	4
	RAR	AL
	CALL	..nibble
	POP	AX
..nibble:AND	AL,0x0F
	CMP	AL,0x0A
	JC	..number
	ADD	AL,0x07
..number:ADD	AL,0x30
	HLT	AL
.PutChr:PUSH	AX,BX
	PUSH	CX,DX
	PUSH	BP
	XCHG	CL
	PUSH	[BP+0x64]
	POP	BP
	MOV	CH,[BP+0x0]
	AND	CH,CH
	CALL	..main
	PUSH	BX
	POP	[BP+0x4]
	PUSH	[BP+0x8]
	POP	DX
	ADD	BX,DX
	PUSH	[BP+0xC];3
	POP	DX;1
	DEC	AL;1
	DEC	DX;1
	XCHG	BX,DX	;2
	MOV	AL,DL	;2
..exit:	MOV	[BX],AL	;1
	DEC	BX	;1
	MOV	[BX],DH	;1
..leave:MOV	AL,CH
..ready:MOV	[BP+0x0],AL
	POP	BP
	POP	DX,CX
	POP	BX
..reada:POP	AX
	RET
..main:	PUSH	[BP+0x4]
	POP	BX
	PUSH	[BP+0x6]
	POP	DX
	JNZ	..ansi
	MOV	AL,CL
	CMP	AL,0x1B
	JNZ	..out
	MOV	[BP+0xFF],CH
	DEC	CH
	RET
..left:	DEC	BL
	RNS
	MOV	BL,DL
	DEC	BL
..up:	DEC	BH
	RNS
	MOV	BH,DH
	DEC	BH
	RET
..right:INC	BL
	CMP	BL,DL
	RC
	XOR	BL,BL
..down:	INC	BH
	CMP	BH,DH
	RC
	XOR	BH,BH
	RET
..clrscr:XOR	CL,CL
	MOV	BH,CL
	MOV	BL,CL
...loop:CALL	..put
	JNZ	...loop
	DEC	DL
..home:	XOR	BH,BH
..return:MOV	AL,0x20
..set_x:SUB	AL,0x20
...loop:MOV	BL,AL
	SUB	AL,DL
	JNC	...loop
	XOR	CH,CH
	RET
..quit:	JZ	..exit
..out:	CMP	AL,0x0A
	JZ	..scroll
	CMP	AL,0x0D
	JZ	..return
	CMP	AL,0x08
	JZ	..left
	CMP	AL,0x18
	JZ	..right
	CMP	AL,0x19
	JZ	..up
	CMP	AL,0x1A
	JZ	..down
	CMP	AL,0x0C
	JZ	..home
	PUSH	[BP+0x12]
	RET
;..clear:JZ	..clrscr
..put:	PUSH	BX
	PUSH	CX
	PUSH	[BP+0xE]
	XCHG	IP,[SP]
	POP	CX
	MOV	AL,[BP+0x3]
	ADD	AL,CL
	MOV	[BX],AL
	POP	BX
	INC	BL
..tab:	CMP	BL,DL
	RC
	XOR	BL,BL
..scroll:INC	BH
	CMP	BH,DH
	RC
	MOV	BH,DH
	DEC	BH
	PUSH	BX
	XOR	BL,BL
	PUSH	BX
	PUSH	[BP+0xE]
	XCHG	IP,[SP]
	XCHG	BX,[SP]
	INC	BH
	PUSH	[BP+0xE]
	XCHG	IP,[SP]
	POP	CX
	SUB	CX,BX
	SKIP	5
...rows:ADD	BX,CX
	MOV	DL,AL
	MOV	AL,[BX]
	MOV	[BX],DL
	CMC
	HLT	2
	WAIT
	INT	50
;	DEC	DH
;	JNZ	...rows
	HLT	DH
	;CMC
...cols:PUSH	DX
	PUSH	BX
	MOV	AL,[BP+0x3]
	CMC
	WAIT
	INT	0
	POP	BX
	POP	DX
	INC	BX
	DEC	DL
	JNZ	...cols
	POP	BX
	MOV	CH,DL
	RET
..ansi:	MOV	AL,CL
	CMP	CH,0xF3
	JNC	..code
	DEC	CH
	CMP	CH,0xF0
	JZ	..set_x
	JNC	..set_y
	INC	CH
	PUSH	[BP+0xE]
	RET
..code:	MOV	AL,CL
	CMP	AL,0x3A
	JNC	..set_y.call
	SUB	AL,0x30
	JC	..set_y.call
	MOV	CL,AL
	POP	AX
	MOV	BL,CH
	XOR	BH,BH
	ADD	BX,BP
	MOV	AL,[BX]
	ADD	AL,AL
	ADD	AL,AL
	ADD	AL,[BX]
	ADD	AL,AL
	ADD	AL,CL
	XOR	DH,DH
	JZ	..quit
..outstd:PUSH	..clrscr
	CMP	CL,0x1F
	RZ
	CMP	CL,0x09
	JZ	...tab
	POP	[SP+0]
	PUSH	..put
	RET
...std:	MOV	CH,0xF2
	CMP	AL,0x59
	RZ
	XOR	CH,CH
	RET
...tab:	POP	[SP+0x00]
	OR	BL,0x07
	INC	BL
	JNZ	..tab
..set_y:SUB	AL,0x20
...loop:MOV	BH,AL
	SUB	AL,DH
	JNC	...loop
	RET
...call:PUSH	[BP+0x10]
	XCHG	IP,[SP]
	PUSH	[BP+0x4]
	POP	BX
	RET
..mul78:PUSH	[BP+0x8]
	POP	CX
	ADD	BX,CX
	MOV	AL,BL
	MOV	BL,BH
	XOR	BH,BH
	ADD	BX,BX
	MOV	CH,BH
	MOV	CL,BL
	ADD	BX,BX
	ADD	BX,BX
	ADD	BX,CX
	ADD	BX,BX
	ADD	BX,BX
	ADD	BX,BX
	SUB	BX,CX
	XOR	CH,CH
	MOV	CL,AL
	ADD	BX,CX
	PUSH	[BP+0xC]
	POP	CX
	ADD	BX,CX
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DL = Port Index[7F:PortIn]
; AL = Data
;	DBG	0x01
;	BRK	0x01
.PortIO:PUSH	DX
	CMP	DL,0x80
	SBB	DH,DH
	ADD	DL,0x81
	JZ	..input
	XCHG	SP,DX
	DEC	SP
	JNS	..lower
	INC	SP
	MOV	[SP+127],AL
	JS	..ready
..lower:MOV	[SP+128],AL
	JNS	..ready
..input:CMP	AL,0x80
	SBB	DH,DH
	ADD	AL,0x81
	MOV	DL,AL
	XCHG	SP,DX
	JZ	..ready
	JS	..higher
	DEC	SP
	MOV	AL,[SP+128]
	JNS	..ready
..higher:MOV	AL,[SP+127]
..ready:XCHG	SP,DX
	POP	DX
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CX - Register Index
; DX - Register Data
.CPU_In:PUSH	CX
	PUSH	BX
	XOR	BH,BH
	MOV	BL,BH
	DEC	BX
	XCHG	SP,BX
.loop:	POP	DX
	DEC	CX
	MOV	AL,CL
	OR	AL,CH
	JNZ	.loop
	XCHG	SP,BX
	POP	BX
	POP	CX
	RET
;;;;;;;;;;;;;;;;;;;;;;
.PortIn:PUSH	BX
	BIAS	..input
	POP	BX
	MOV	BL,AL
	XCHG	BP,BX
..input:MOV	AL,[BP+0]
	XCHG	BP,BX
	POP	BX
	RET
;;;;;;;;;;;;;;;;;;;;;;
.WaitOut:PUSH	BX,CX;DL = Data
	XCHG	CL
	BIAS	..input
	POP	BX
	MOV	BL,AL
	XCHG	BP,BX
	SUB	AL,AL
	HLT	CL
	WAIT
..input:MOV	[BP+0],DL
	ADD	CL,0xFF
	XCHG	BP,BX
	POP	CX,BX
	RET
.WordOut:
;;;;;;;;;;;;;;;;;;;;;;
.OutByte:PUSH	DX,AX;XH = Time, XL = Port, AL = Byte
	PUSH
	POP	DX
	CALL	..next
	POP	AX,DX
	RET
..next:	PUSH	AX
	LOOP	4
	RCR	AL
	CALL	..loop
	POP	AX
..loop:	AND	AL,0x0F
	ADD	AL,0xC0
.Output:PUSH	DX,BX;XH = Time, XL = Port, AL = Data
	PUSH
	POP	DX
	BIAS	..loop
	POP	BX
	MOV	BL,DL
	XCHG	BP,BX
	SUB	DL,DL
	HLT	DH
	WAIT
..loop:	MOV	[BP+0],AL
	ADD	DH,0xFF
	XCHG	BP,BX
	POP	BX,DX
	RET
;;;;;;;;;;;;;;;;;;;;;;
.FileIn:INT	72
	DB	"\r\nFILE LIST - \0"
	MOV	DL,0xFD
	MOV	DH,0x02
	HLT	DX
	MOV	AL,0x00
	CALL	.OutByte
	MOV	AL,0x00
	CALL	.OutByte
	MOV	AL,0xD3
	CALL	.Output
	CALL	.WaitIn
..loop:	PUSH	AX
	INT	72
	DB	"\r\n#\0"
	HLT	AL
	PUSH	BIOS.PutHex
	XCHG	IP,[SP]
	INT	72
	DB	" - \0"
	MOV	AL,0xFD
	MOV	CL,0x02
	MOV	DL,0x00
	HLT	CL
	CALL	.WaitOut
	CALL	.WaitOut
	CALL	.WaitOut
	MOV	DL,[SP+0]
	AND	DL,0x0F
	OR	DL,0xC0
	CALL	.WaitOut
	MOV	DL,0xD1
	CALL	.WaitOut
..print:CALL	.WaitIn
	HLT	AL
	INT	71
	JC	..print
	HLT
;;;;;;;;;;;;;;;;;;;;;;
.WaitIn:PUSH	BX,CX
	XCHG	CL
	BIAS	..input
	POP	BX
	MOV	BL,AL
	XCHG	BP,BX
	SUB	AL,AL
	HLT	CL
	WAIT
..input:MOV	AL,[BP+0]
	ADD	CL,0xFF
	XCHG	BP,BX
	POP	CX,BX
	RET
;;;;;;;;;;;;;;;;;;;;;;
.GetChar:XOR	AL,AL
..loop:	CALL	.Inkey
	JNC	..loop
	PUSH	AX
	PUSH	CX
	MOV	CL,0x50
	MOV	CH,0xF0;01;0xF0
	XOR	AL,AL
	CZ	.beep
	POP	CX
	POP	AX
	RET
.Inkey:	PUSH	DX
	MOV	DL,0x7F
	MOV	AL,0xFD
	MOV	DH,0x80
	HLT	DH
	PUSH	BIOS.WaitIn
	XCHG	IP,[SP]
	POP	DX
	RET
.beep:	PUSH	DX
	MOV	DL,0x0A
	MOV	AL,CL
	PUSH	.PortIO
	XCHG	IP,[SP]
	MOV	AL,CH
	LOOP	AL
	NOP
	PUSH	.PortIO
	XCHG	IP,[SP]
	POP	DX
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ORG	0xFF00
KERNEL:	JMP	.errors	;0#PUSHed AX
	JMP	.events	;1#PUSHed AX
	JMP	.memory	;2#PUSHed AX
	JMP	.tasks	;3#PUSHed AX
	JMP	.device	;4#PUSHed AX
	JMP	.quest	;5#PUSHed AX
	JMP	.break	;6#PUSHed AX
	JMP	.start	;7#
.errors:NOP
.events:NOP	1
.memory:NOP	2
.tasks:	NOP	3
.quest:	NOP	5
.break:	NOP	6
.start:		; Init task #1
	MOV	CL,0xE6
	IN	CL
	MOV	DL,0xA5
	OUT	CL,DL
	MOV	BH,0xD0
	MOV	BL,0x00
	XCHG	SP,BX
	PUSH	0xF800
	POP	BX
	MOV	BH,0xD0
	MOV	BL,0x00
	PUSH	BX
	POP	SI
	XOR	DH,DH
	MOV	DL,0x01
..loop:	PUSH	SI
	LOOP	4
	LEA	SI,DX+SI
	MOV	BL,[SI+0]
	MOV	BH,[SI+1]
	MOV	CL,[SI+2]
	MOV	CH,[SI+3]
	MOV	AL,CL
	OR	AL,CH
	MOV	AL,DL
	INC	DX
	POP	SI
	CNZ	.context.init
	JNZ	..loop
	DEC	DL
	XCHG	SI,BX
	INC	BX,BX
	INC	BX,BX
..jumps:PUSH	DX,BX
	XOR	DH,DH
...run:	DEC	DL
	JZ	...all
	INC	BX,BX
	MOV	AL,[BX]
	MOV	[6],AL
	INC	BX
	MOV	AL,[BX]
	MOV	[7],AL
	INC	BX
	INC	DH
...next:MOV	AL,DH
	LOOP	4
	ADD	AL,AL
	ADD	AL,DH
	MOV	[0],AL
	JMP	.errors	;0#PUSHed AX
	JMP	.events	;1#PUSHed AX
	JMP	.memory	;2#PUSHed AX
	JMP	...run	;3#PUSHed AX
	JMP	.device	;4#PUSHed AX
	JMP!	.quest	;5#PUSHed AX
	JMP!	.break	;6#PUSHed AX
	JMP!	.start	;7#
...all:	POP	BX,DX
	JMP	..jumps
.device:XOR	AL,AL
	MOV	[0],AL
	POP	AL
	IN	AL
	PUSH	AL
	MOV	CL,0x80
	MOV	CH,0xFF
	MOV	[CL],CH
	JMP	.start.jumps.next
.context:	; Context trigger
..init:		; Context init (BX=IP,CX=Ticks,AL=Index)
	PUSH	AX
	LOOP	4
	ADD	AL,AL
	MOV	[0],AL
	MOV	AL,0xF0
	HLT	AL
	WAIT
	HLT	BL
	ADD	AL,0x08
	WAIT
	HLT	BH
	PUSH	0xE000
	POP	BX
	MOV	AL,0xF7
	HLT	AL
	WAIT
	HLT	BL
	ADD	AL,0x08
	WAIT
	HLT	BH
	POP	AX
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ORG	0x7650
	DW	0x0000	; Value .Sequency
	DW	0x0000	; Page  .Blank
	DW	0x0000	; PosY  .PosX
	DW	0x1E48;0x1E4E;	0x1940	; Rows  .Columns
	DW	0x0000;0x0308	; FromY .FromX
	DW	0x05F0	; Bell  .Tone
	DW	0x76D0
	DW	BIOS.PutChr.mul78
	DW	BIOS.PutChr.OutStd.std
	DW	BIOS.PutChr.OutStd
	DW	0x7650
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ORG	0xD000
PROCESS:DW	0x0000,0x0000	;#0
	DW	0xF800,0xFFFF	;#1
	DW	0xF000,0x0001	;#2
	DW	0x0000,0x0000
</pre>
</td>
<td rowspan='2'><pre>
Rebused Instructions Set Computer Emulator
</pre><hr /><pre>
F1: Step / ^Cycle / $Stop
F3: ^Push IP / $Pop IP
F4: Start/Stop / $Start
F5: Assembly / ^Reset
F6: Rewind  IP/Speed/Cycles
F7: Toggle switch
F8: Forward IP/Speed/Cycles
F9: 
Break: Toggle break-point
</pre><hr /><pre>
$ - Shift+
^ - Ctrl+
@ - Alt+
</pre><hr /><pre>
Intuitive clear mnemonic to quick memorize
|Codes|Key|Elementary description_________
  00  :Nil-Null of instruction queue / HLT
xA..xB:A/B-Add / Subtract
xC..xD:C/D-Conjunction / Disjunction
  xE  : E -Exclusive bitwise OR
A0..A7: A -Access to bytes
A8..AF:A/A-Access to ALU
B0..B7: B -Branches to nearest substitutes
B8..BF:B/F-Branches to near labels by flag
C0..C7: C -Increment
  CA  :RAL-Concatenate Access roll
  CF  :C/F-Carry Flag complement
D0..D7: D -Decrement
  DA  :RAR-Descended Access roll
  DF  :D/F-Data Formation by NOT
  EE  :E/E-Exchange
F0..F9:F/x-Functions of BIOS-API
  FE  :F/E-Fiction Execute / NOP
  FF  :F/F-Finalize the Function / RET
+EC/ED:Exclude operations by Counter/Data
+FC/FD:Forcing operation by Counter/Data
 +EF  :E/F-Enter register Feature
 +FF  :F/F-Flush register Feature
Simplest protection from errors in code:
Examples|Macros
CF BC FD|CLC   ; Clear the Carry Flag
CF BD FD|STC   ; Store the Carry Flag
BE FF   |RZ    ; Return by Zero Flag
BF FF   |RNZ   ; Return by no Zero Flag
</pre>
</td>
</tr>
<tr valign=top><td><canvas id=Display style=position:absolute  onblur='cpu.watch.active=""' onfocus='cpu.watch.active="S"'></canvas><pre id=Screen style=width:40em></pre>
<span style='background-color:silver; display:inline-block; color:black; height:33em'>
</span>
</td>
<td style='background-color:silver; color:black'>
<select id=Selector></select><button id=Action value=Files></button><br />
<pre id=state></pre>
</td>
</tr></table>
<textarea id='Files' cols='80' rows='50'>
	FILE	XONIX
	ORG	0x0100
Xonix:	PUSH	0xF800
	POP	BX
	RET
;NEXT-FILE;
	FILE	TETRIS
	ORG	0x0100
Tetris:	INC	BX
	RET
</textarea>
<!--
i8275 CRT-Controller: Simply version
00000000: 
000000nn: 
000001nn: 
00001nnn: 
0001nnnn: 
0010nnnn: 
0100nnnn: Lines [1..16]-1
01nnnnnn: Rows [16..64]-1
1000nnnn: 
1nnnnnnn: Cols [16..80]-1
1101nnnn: 
1110nnnn: 
1111nnnn: 

40..4F: Set Lines [1..16]
50..7F: Set Rows [16..64]
90..CF: Set Cols [16..80]

=== PORTS ===
SP:0000
[SP-1]  =FFFF -> Port $FF
[SP-128]=FF80 -> Port $80
SP:FFFF
[SP+1]  =0000 -> Port $00
[SP+127]=007E -> Port $7E
;;;;;;;;
; DL = Port Index[7F:PortIn]
; AL = Data
PortIO:	PUSH	DX
	CMP	DL,128
	SBB	DH,DH
	ADD	DL,129
	JZ	.input
	XCHG	SP,DX
	JNS	.lower
	MOV	[SP+127],AL
	JS	.ready
.lower:	MOV	[SP-128],AL
	JNS	.ready
.input:	CMP	AL,128
	SBB	DH,DH
	ADD	AL,129
	MOV	DL,AL
	JZ	.ready
	XCHG	SP,DX
	JS	.higher
	MOV	AL,[SP-128]
	JNS	.ready
.higher:MOV	AL,[SP+127]
.ready:	XCHG	SP,DX
	POP	DX
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;
Port #253 #0xFD #-3	: Keyboard Code
;;;;;;;;;;;;;;;;;;;;;;;;;
x0 x1 x2 x3 x4 x5 x6 x7
-- BP SI DI SP BX CX DX

55 76 -> PREFIX BX + MOV CL,DL   -> PREFIX BX + MOV CX,DX -> LEA BX,[CX+DX]
55 21 -> PREFIX BX + MOV BH,CH   -> PREFIX BX + MOV BP,SI -> LEA BX,[BP+SI]
55 10 -> PREFIX BX + MOV [BX],BH -> PREFIX BX + MOV XX,BP -> LEA BX,[[SP]+BP]

/////////////////////////////////////////////////////////////////////////////
Service Registers:
==================
1. Select the service segment:
1.1. Set SP to 0x0001
1.2. Set APR (one of BX,CX,DX) to wanted index
1.3. Do PUSH instruction of this APR
2. Select the service register:
2.1. Set SP to 0x0000
2.2. Set AL to wanted index
2.3. Do PUSH AX
2.4. If wanted index greater than 256, repeat the step #2.3 many times
3. Write to service register:
3.1. Set SP to 0x0000
3.2. Do PUSH instruction with any of APR (BX,CX,DX)
4. Read the service register:
4.1. Set SP to 0xFFFF
4.2. Do POP instruction with any of APR (BX,CX,DX)

-F80..-FFF: Service Layer #1
0000..00FF: Service Layer #0
0100..01FF: 6502-Stack Mode
0200..FDFF: Regular Stack
FE00..FEFF: Service Layer #2
FF00..FFFF: Service Layer #3
+000..+07E: Service Layer #1

00000000XXXXXXXX: Service Layer #0
00000001XXXXXXXX: 6502-Stack Layer
XXXXXXXXXXXXXXXX: Regulat Stack Layer
11111110XXXXXXXX: Service Layer #2
11111111XXXXXXXX: Service Layer #3

┌───┬───┬───┬───┬───┬───┬───┬───┐┌───┬───┬───┬───┬───┬───┬───┬───┐┌───┬───┬───┬───┬───┬───┬───┬───┐
│ -   -   -   -   -   -   -   - ││ 0   └──SRC──┘   0   └──DST──┘ ││ -   -   -   -   -   -   -   - │:
└───────────────────────────────┘└───────────────────────────────┘└───────────────────────────────┘

SPCZ
0000
0001
0010
0011
0100
0110
1000
1010
1100
1110

0###sP?Z| Parity Zero:
0###Sp?Z| Signed Zero:Skip # instructions
0###SP?Z| Spouts Zero:Loop instruction # times
1###sP?Z| Parity Zero:
1###Sp?Z| Signed Zero:Skip # instructions
1###SP?Z| Spouts Zero:Loop instruction # times

LOOP  :
LOOP n:Loop instruction n-times	|FX=0nnn11?1
LOOP R:Loop instruction R-n time|FX=1rrr11?1
MOV  R:Using R-register		|FX=1rrr????
NOP  n:Skip n instructions	|FX=0nnn10?1



   Bx nn: 0000..007F FF80..FFFF
11 Bx nn: 0100..017F 0080..00FF
22 Bx nn: 0200..027F 0180..01FF
33 Bx nn: 0300..037F 0280..02FF
44 Bx nn: Services
55 Bx nn: FD00..FD7F FC80..FCFF
66 Bx nn: FE00..FE7F FD80..FDFF
77 Bx nn: FF00..FF7F FE80..FEFF

   Fn:  |Basic library:
11 Fn:  |Memory library:
22 Fn: "|String library:
33 Fn: #|Sound library:
44 Fn: D|Data process:
55 Fn: U|
66 Fn: f|File system: 
77 Fn: w|Window service:
////////////////////////////////////////////////////////////////////////////////
EX-Register
__ .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F
00:Ячейки управления распределением страниц памяти|RAM Dispatcher
10:Ячейки управления распределением страниц памяти|RAM Dispatcher
20:Ячейки управления ловушками в процессе отладки-|Debug Managing
30:Счётчики тактов, циклов, прерываний и т.д.-- --|Process Counters
40:JP>>LO>> ++ .. -- -- -- JP>>HI>> ++ .. -- -- --|JP-File
50:SP>>LO>> ++ .. -- -- -- SP>>HI>> ++ .. -- -- --|SP-File
60:BP>>LO>> ++ .. -- -- -- BP>>HI>> ++ .. -- -- --|BP-File
70:IP>>LO>> ++ .. -- -- -- IP>>HI>> ++ .. -- -- --|IP-File
80:SI>>LO>> ++ .. -- -- -- SI>>HI>> ++ .. -- -- --|SI-File
90:DI>>LO>> ++ .. -- -- -- DI>>HI>> ++ .. -- -- --|DI-File
A0:AL>>LO>>Стек истории -- AH>>HI>> ++ .. -- -- --|AX-File
B0:BL>>LO>>модификации- -- BH>>HI>> ++ .. -- -- --|BX-File
C0:CL>>LO>>всех РОН- -- -- CH>>HI>> ++ .. -- -- --|CX-File
D0:DL>>LO>> ++ .. -- -- -- DH>>HI>> ++ .. -- -- --|DX-File
E0:Стек конвейера с историей исполненных операций-|Execution Pipeline
F0:-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|Execution Pipeline
+0:Зона особого назначения ???????????????????????|Service context
EX-Регистр - хранит контекст процессора.
Ячейками с 50h по DFh непосредственно связаны все РОН в режиме стекового файла с
глубиной до 8 уровней. Тем самым, когда какой-либо регистр изменяется, автоматом
история его изменений циклически сдвигается от ячейки с x0h/x8h к ячейке x7h/xFh
соответственно. Это позволяет в отладчике частично прокрутить историю исполнения
кода в обратном направлении. Так, ячейки 0-FFh доступны программе в произвольном
доступе. Ячейка +0 - это 256 управляющая ячейка управления переключением страниц
контекста, доступная только операционной системе, хранящая маску доступности для
остальных ячеек +1..+7 (257..263).
Битами этих сервисных ячеек можно "заморозить" историю контекста, чтобы получить
произвольный и точный доступ ко всем доступным моментам или сохранить контекст и
подготовить его для переключения к следующей задаче.
////////////////////////////////////////////////////////////////////////////////
Порты: Доступ к устройствам ввода/вывода
========================================
Пользовательский уровень:
Доступ к устройствам операционной среды достигается префикс-инструкц

0###sP?Z| Parity Zero:Пропускать следующие инструкции на период декрементации;
0###Sp?Z| Signed Zero:Повторять следующую инструкцию в периоде декрементации;
0###SP?Z| Spouts Zero:Повторять следующую инструкцию в ожидании декрементации;
1###sP?Z| Parity Zero:
1###Sp?Z| Signed Zero:Skip # instructions
1###SP?Z| Spouts Zero:Loop instruction # times
////////////////////////////////////////////////////////////////////////////////
Скачать:Ольга Кормухина - Тянешь руки в небеса
	Metallica - Unforgiven
-->
<pre id='List'>
</pre>
</body>