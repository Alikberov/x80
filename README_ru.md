| :ru: | [:uk:](README.md) |
| --- | --- |

# x80 - i8080-ПРАв<i>ә</i>льный
#### РИСК-Технология (Ребусного Инструкционного Состава Компьютер)
История попыток создания модели процессора с интуитивно ясным набором команд.
- [x] Страничка [викии](http://x80.wikia.com/)
  - [x] i8080 частичная совместимость по командам (краткость, методы, простота)
  - [x] i8086 частичная совместимость по ассемблеру (гибкость, указатели, регистры)
  - [ ] i8080/i8086/z80 совместимость по машинному коду напрямую не предусматривается
- [x] [Запустить :arrow_forward:](https://htmlpreview.github.io/?https://github.com/Alikberov/x80/blob/master/emulator.html?speed=10&reset=1000&cycle=1024&debug=FFFF) демонстрацию в браузере

#### Основной план
- [x] CPU-182:
  - [x] 1-байтовый относительный скачок ветвлений (Jcnd $-128 .. $+127)
  - [x] 8-битные РОН (BH CH DH AL BL CL DL)
  - [x] 16-битные регистровые пары (BX CX DX)
  - [x] 16-битные указатели (IP SP BP SI DI)
  - [x] 16-битная страница ОЗУ [0..65535]
- [x] CPU-18x:
  - [ ] 08x - Нуль-битный ALU (опытный фактор)
  - [x] 18x - 8-битный ALU
  - [ ] 28x - 16-битный ALU
  - [ ] 38x - 32-битный ALU
  - [ ] 48x - 64-битный ALU
- [x] CPU-x82:
  - [ ] x80 - Релиз нуль-модификации (опытная модель)
  - [ ] x81 - Модель первой модификации
  - [x] x82 - Модель второй модификации
  - [ ] x83 - модель третьей модификации
- [ ] CPU-284:
  - [x] 2-байтовый относительный скачок ветвлений (Jcnd $-32768 .. $+32767)
  - [x] 16-битные РОН (BH CH DH AL BL CL DL)
  - [x] 32-битные регистровые пары (BX CX DX)
  - [x] 24-битные указатели (IP SP BP SI DI)
  - [x] 24-битная страница ОЗУ [0..16777215]
- [ ] CPU-386:
  - [x] 3-байтовый относительный скачок (Jcnd $-8388608 .. $+8388607)
  - [x] 32-битные РОН (BH CH DH AL BL CL DL)
  - [x] 64-битные регистровые пары (BX CX DX)
  - [x] 32-битные указатели (IP SP BP SI DI)
  - [x] 32-битная страница ОЗУ [до 4 Гб]

Никаких x86-костылей, как EAX или RIP. Имена регистров не меняются, меняется их разрядность.
<hr />
Вы уверены, что архитектура i8080 безнадёжно устарела? А Z80 - самый удачный его клон?
Современными технологиями можно воссоздать программирование под модернизированную архитектуру.
Почему бы не попробовать?
<hr />
### Подробности

```
00: HLT - Всюду НОЛЬ - конец всего (например, файла, текста), т.к. это - логично;
80: NOP - Арифметическая петля -(-128) равно -128 - пустое действие;
FF: RET - Анти-НОЛЬ - анти-конец или продолжение основного с концом текущего.
```

:repeat_one: Воспроизведение i8080-костылей:

```
   ┌─►RET         Example:
Bx FF:Jcond $+1─┐ 1.RZ
┌──┘┌►Rcond     │ 2.RNZ
└───┴───────────┘ 3.RPO
```

:repeat: Воспроизведение x86-костылей:

```
Bx FE:Jcond $+0─┐ 1.REPZ
↑ ┌►REPcond     │ 2.REPNZ
└─┴─────────────┘ 3.REPPO
```

:repeat_one: Воспроизведение вызовов скрытых функций через пустой вызов:

```
   ┌─►RET         Example:
Bx FF:Ccond $+1─┐ 1.DAA
┌──┘┌► «Other»  │ 2.CLI/STI
└───┴───────────┘ 3.CPUID
```

:repeat: Воспроизведение сложных команд через петлю переполнения стека:

```
Bx FE:Ccond $+0─┐ 1.WAIT
↑ ┌► «Complex»  │ 2.MUL/DIV
└─┴─────────────┘ 3.MOVS/CMPS
```

<hr />
[:page_facing_up: Таблица команд](http://htmlpreview.github.com/?http://github.com/Alikberov/x80/blob/master/emulator.html?instructions) составлялась с интуитивно ясной позиционной логикой:

```
Ax: Ассигнации регистров / ALU-операции;
Bx: Ветвления;
Dx: Декременты;
Fx: Функции.
```

:heavy_check_mark: Удачные решения (к запоминанию):

```
AB: ALU - Вычитание       (SUB);
AD: ALU - Дизъюнкция      (OR);
AE: ALU - Эксклюзивное ИЛИ(XOR);
... . . . . . . . . . . . . . .
BE: Ветка, если Эквивалент равенству
BF: Ветка, если Фиктивное равенство
... . . . . . . . . . . . . . .
DC: Декремент CX-указателя;
DD: Декремент DX-указателя;
... . . . . . . . . . . . . . .
CF: Смена Флага переноса  (CMC);
F0..F7: Функция #n        (INT n);
FF: Функциональный Финиш  (RET);
```

:grey_question: Экспериментальные наброски:

```
   ┌──┬──┬──┬──┬──┬──┬──┬──┐
AH:│??│??│TF│WF│PF│SF│CF│ZF│
   └──┴──┴──┴──┴──┴──┴──┴──┘
Флаговый Регистр (AH - ALU Heap):
Бит 0:Zero  (Нулевой флаг отвечает за Ноль);
Бит 1:Carry (Первый флаг отвечает за перенос 1 бита);
Бит 2:Signed(n - 2n = -n);
Бит 4:Word  (1<<4 = 16-битовый режим);
Бит 5:Trace (1<<5 = Тридцать два  - Трассировка)
```

:grey_question: Особенности системного кода:

```
00: Префикс SS (не HLT-останов);
```

### Расширенная арифметика
Система команд позволяет производить реверсивные операции АЛУ над аккумулятором (SUB, SBB, CMP):

```
   5B   |SUB AL,BL   ; AL = AL - BL
   AB 7F|SUB AL,0x7F ; AL = AL - 0x7F
33 5B   |SUB DH,BL   ; DH = DH - BL
33 AB 7F|SUB DH,0x7F ; DH = DH - 0x7F
44 5B   |SUB BL      ; AL = BL - AL
44 AB 7F|SUB 0x7F    ; AL = 0x7F - AL
.. .. ..
   5F   |CMP AL,BL   ; Test(AL - BL)
   AF 7F|CMP AL,0x7F ; Test(AL - 0x7F)
33 5F   |CMP DH,BL   ; Test(DH - BL)
33 AF 7F|CMP DH,0x7F ; Test(DH - 0x7F)
44 5F   |CMP BL      ; Test(BL - AL)
44 AF 7F|CMP 0x7F    ; Test(0x7F - AL)
```

Так как остальные реверсивные операции бессмысленны (ADD,ADC,AND,OR,XOR), они работают как операции сравнения:

```
   5C   |AND AL,BL   ; AL = AL & BL
   AC 7F|AND AL,0x7F ; AL = AL & 0x7F
33 5C   |AND DH,BL   ; DH = DH & BL
33 AC 7F|AND DH,0x7F ; DH = DH & 0x7F
44 5C   |AND BL      ; Test(BL & AL)
44 AC 7F|AND 0x7F    ; Test(0x7F & AL)
```

<hr />
## Системные трюки
### Порты ввода/вывода
Доступ к памяти с относительным смещением от указателя и выходом за границы в 64кб обрабатывается как доступ к внешним устройствам.

```
        MOV  AL,[SP-1] ; Равно, как IN AL,255 если SP равен 0x0000
        MOV  [SP+1],AL ; Равно, как OUT 1,AL если SP равен 0xFFFF
```

### Системный контроль процессора
Процессор не имеет особых операций управления внутренним состоянием.
Все действия с командами PUSH/POP обеспечивают доступ к внутренним регистрам, если SP-указатель лежит на границе памяти.
Если указатель стека ОБНУЛЁН или выставлен в максимум, нормальная работа команд PUSH/POP невозможна и обращается ко внутренним служебным ресурсам (регистрам отладки, контекста задачи, обратной совместимости с i8080/z80).
Как правило, операционная среда должна контролировать подобные действия приложений, прерывая или симулируя нужные действия.

```
	PUSH DX ; Если SP равен 0x0000, DX записывается в сервисные регистры
	PUSH AX ; Пропустить текущий сервисный регистр
	POP  DX ; Если SP равен 0xFFFF, DX читается из сервисных регистров
	POP  AX ; Пропустить текущий сервисный регистр
	PUSH CX ; Если SP равен 0x0001, CX индексируется страницу сервиса
```

В частности, это другой способ работы с портами ввода/вывода.
Как вариант, если индекс страницы содержит шестнацатиричную букву ("A".."F"), она считается системной и закрыта для прикладного кода.
